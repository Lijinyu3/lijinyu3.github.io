{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6b22\u8fce\u6765\u5230Li's blog \u8bb0\u5f55\u6211\u7684\u65e5\u5e38\u3002 Contact email: enotaa33@gmail.com","title":"Home"},{"location":"#lis-blog","text":"\u8bb0\u5f55\u6211\u7684\u65e5\u5e38\u3002","title":"\u6b22\u8fce\u6765\u5230Li's blog"},{"location":"#contact","text":"email: enotaa33@gmail.com","title":"Contact"},{"location":"notes/","text":"\u8bb0\u5f55\u6211\u5b66\u4e60\u7684\u8bfe\u7a0b\u3002","title":"Home"},{"location":"notes/Harvard_CS50/","text":"CS50 \u662f\u54c8\u4f5b\u5927\u5b66\u7684\u4e00\u95e8CS\u5165\u95e8\u8bfe\u3002\u8bfe\u7a0b\u5168\u7a0b\u662f Introduction to the intellectual enterprises of computer science and the art of programming. \uff0c\u5373\u8ba1\u7b97\u673a\u79d1\u5b66\u4e0e\u7f16\u7a0b\u8bbe\u8ba1\u827a\u672f\u5bfc\u8bba\u3002 \u8bfe\u7a0b\u4e3b\u9898\u5305\u62ec\u62bd\u8c61\uff08Abstraction\uff09\u3001\u7b97\u6cd5\u3001\u6570\u636e\u7ed3\u6784\u3001\u5c01\u88c5\uff08encapsulation\uff09\u3001\u8d44\u6e90\u7ba1\u7406\uff08Resrouce management\uff09\u3001\u5b89\u5168\u3001\u8f6f\u4ef6\u5de5\u7a0b\u3001Web\u7f16\u7a0b\u3002\u53ef\u4ee5\u8bf4\u628a\u8ba1\u7b97\u673a\u5927\u90e8\u5206\u9886\u57df\u90fd\u901b\u4e86\u4e2a\u904d\u3002\u6559\u4e86C\u3001Python\u3001SQL\u3001HTML\u3001CSS\u3001JavaScript\u8bed\u8a00\u3002 \u8fd9\u95e8\u8bfe\u65e0\u987b\u524d\u7f6e\u7684\u4efb\u4f55\u8ba1\u7b97\u673a\u77e5\u8bc6\uff0c\u5bf9\u521d\u5b66\u8005\u53ca\u5176\u53cb\u597d\uff0c\u5e26\u4f60\u5165\u95e8\u8ba1\u7b97\u673a\u5b66\u79d1\u3002\u8bfe\u540eLab\u4e5f\u5f88\u6709\u610f\u601d\uff0c\u6d89\u53ca\u5230\u827a\u672f\u3001\u4eba\u6587\u3001\u793e\u79d1\u3001\u79d1\u5b66\u9886\u57df\u3002 \uff08\u5b98\u7f51\u662f\u8fd9\u4e48\u8bf4\u7684\uff0c\u867d\u7136\u6ca1\u8fd9\u4e48\u5938\u5f20\uff0c\u4f46\u662f\u6d89\u53ca\u9762\u786e\u5b9e\u5e7f\uff0c\u4e00\u8fb9\u6e29\u6545\u77e5\u65b0\u521a\u5b66\u7684CS\u77e5\u8bc6\uff0c\u4e00\u8fb9\u4e86\u89e3\u4e00\u4e9b\u5176\u5b83\u9886\u57df\u7684\u77e5\u8bc6\u3002SQL\u90a3\u4e00\u8282\u4e22\u5931\u7684\u5c0f\u9ec4\u9e2d\u5de8\u597d\u73a9\uff0c\u7ed9\u67af\u71e5\u7684SQL\u8bed\u53e5\u5e26\u6765\u51e0\u5206\u8da3\u5473\uff09 David Malan\u6559\u6388\u662f\u6211\u89c1\u8fc7\u8bb2\u8bfe\u6700\u6709\u6fc0\u60c5\u7684\uff0c\u8bed\u901f\u50cf\u673a\u5173\u67aa\uff0c\u4f46\u662f\u4ecd\u7136\u80fd\u4fdd\u8bc1\u8bb2\u7684\u4e1c\u897f\u6709\u6761\u7406\u3002``\u4ed6\u4f3c\u4e4e\u4ece\u5f88\u65e9\u5c31\u8bb2\u8fd9\u95e8\u8bfe\u4e86\u3002\u52a9\u6559Brian\u662f\u4e2a\u534e\u88d4\uff0c\u8bfe\u540e\u7684Lab\u4f1a\u6709\u4ed6\u7684\u89c6\u9891\u7ed9\u4f60tips\u3002 \uff08CS50\u662f\u6211\u5b66\u4e60\u7684\u7b2c\u4e00\u95e8\u82f1\u6587\u8bfe\uff0c\u7b2c\u4e00\u8282\u8bfe\u6211\u770b\u4e86\u5f97\u6709\u4e94\u516d\u4e2a\u5c0f\u65f6\uff0c\u5c31\u56e0\u4e3aDavid\u7684\u673a\u5173\u67aa\u8bed\u901f\u548c\u6211\u53ef\u601c\u7684\u82f1\u8bed\u542c\u529b\u80fd\u529b\uff09 1. Expectations Watch eleven lectures, Complete ten labs, Solve ten problem sets, Take nine quizzes, Take one test, and Design and implement a final project. 2. Lectures Week 00 Scratch Week 01 C Week 02 Arrays Week 03 Algorithms Week 04 Memory Week 05 Data Structures Week 06 Python Week 07 SQL Week 08 HTML, CSS, JavaScript Week 09 Flask Week 10 Ethics","title":"Syllabus"},{"location":"notes/Harvard_CS50/#1-expectations","text":"Watch eleven lectures, Complete ten labs, Solve ten problem sets, Take nine quizzes, Take one test, and Design and implement a final project.","title":"1. Expectations"},{"location":"notes/Harvard_CS50/#2-lectures","text":"Week 00 Scratch Week 01 C Week 02 Arrays Week 03 Algorithms Week 04 Memory Week 05 Data Structures Week 06 Python Week 07 SQL Week 08 HTML, CSS, JavaScript Week 09 Flask Week 10 Ethics","title":"2. Lectures"},{"location":"notes/Harvard_CS50/0x00_Scratch/","text":"1. What is computer science? Computer science is fundamentally problem solving . What is problem solving is as the process of taking some input (i.e., details about our problem), and then generate some output (i.e., the solution to our problem). The black box in the middle is Computer Science, that is the code we'll learn to write. To begin doing that, we'll need a way to represent input and output , so that we can store and work with information in a standardized way . 2. Representing numbers 2.1. Unary When we counting the number of people in a room, probably we can do it with our hand, that is we raise one finger at a time to represent each person. It's stupid but simple, and we won't be able to count very high. This system is unary , where each digit represents a single value of one. 2.2. Decimal As we know, we have a more efficient system to represent numbers, where we have 10 digits, 0 through 9. 0 1 2 3 4 5 6 7 8 9 This system is called decimal , or base 10 , since there are 10 different values that a digit can represent. 2.3. Binary Computer use a simpler system called binary , or base 2 , with only two possible digits, 0 or 1. Since computer run on electricity , there are two states of an electronic switch, which can be turned on or off. We can conveniently represent a bit by turning a switch on or off to represent a 0 or 1. 3. Text 3.1. Map and ASCII Since the computer can only represent number in binary, so if we wanna represent text or a single letter, we need to map the numbers to letters, e.g., 'A' can be mapped to 65, and 65 is a Decimal number, it's 01000001 whose representation of 65 in binary. Fortunately, we needn't to decide the correspondences of each letter mapping. There is a standard mapping, ASCII ( American Standard Code for Information Interchange ), which include the mapping of higher-case, lower letters and punctuation. 3.2. one Byte = 8 Bits E.g., If we received a text message with a pattern of bits that had a decimal values 72 , 73 and 33 , those would map to the letters HI . Each letter actually is typically represented with a pattern of eight bits , or a byte. So, the sequences of bits we would receive are 01001000 , 01001001 , and 00100001 . Byte is the unit of measurement for data with which we might already be familiar, as in megabytes(MB) or gigabytes(GB), for million or billions of bytes. With eight bits, or one byte, there are 2^8^, or 256 different values (including zero), and the highest value we can count up to would be 255. 3.3. Unicode Can we represent any characters by using one byte? We know one byte have 2^8^ different values, so one byte can represent 2^8^ = 256 characters. Of course it's more than 256 characters that the character of languages all around the world, such as Asian language, Islam language etc. What's more, there are also other characters such as letters with accent marks and symbols. They are part of a more generally standard called Unicode , which uses more bits than ASCII to accommodate all the characters. Concretely, when we receive an emoji, out computer is actually receiving a number in binary that it then maps to the image of the emoji based on Unicode standard. For example, the \"face with tears of joy\" emoji is just the bits 000000011111011000000010 : 4. Images, video, sounds 4.1. Images 4.1.1 RGB An image, like the picture of the emoji \"face with tears of joy\" above, are made up of colors . We can still represent each color with only bits, just like how we map numbers to letters, we can map numbers to colors as well. There are many different systems to represent colors, but a common one is RGB , which represent a color by indicating the amount of red , blue and green within each color. And our programs would know those bits map to a color if we opened an image file , as opposed to receiving them in a text message(map to letters). 4.1.2 Pixels We know that there are lots of dots in a photo if we zoom in, e.g., the emoji above: These dots, or squares are called pixels , and image are made up of many thousands or millions of those pixels as well. There are three bits to represent the amount of red, blue and green color in this pixel. For example, if we have received this pattern of bits: 72 , 73 , 33 . That indicate the amount of blue is 72 over 255(a bit has 2^8^ different values ), and so on. So we'll get this eventually: 4.1.3. Resolution The resolution of an image is the number of pixels there are, horizontally and vertically. That means more clear image(High-resolution) we get, more pixels it'll have, and then, more bits required to be stored. That explains why the high-resolution image always need more storage. 4.2. Video Video is a sequence of images, which changing multiple times a second to give us appearance of motion, as an old-fashioned flip-book might do. For us human being, if the images can changing enough multiple times in a second, we cannot discriminate whether it's a sequence of image or a continuous video, with our eyes. 4.3. Sounds Of course music can be represented with bits, with mappings of numbers to notes and durations, or more complex mappings of bits to sound frequencies at each moment of time. 4.4. Others files File formats, like JPEG and PNG, or WORD or EXCEL documents, are also based on some standard that some humans have agreed on, for representing information with bits. 5. Algorithms 5.1. What is Algorithms Now we can represent inputs and outputs with bits, we can concentrate our work on problem solving, where the black box in the middle of the figure before. Algorithms are some step-by-step instructions for solving problem, it's some computings that make the input to the output what we want. Humans can follow algorithms too, such as recipes for cooking. When programming a computer , we need to be more precise with our algorithms so that our instructions aren't ambiguous or misinterpreted. 5.2. Correct and Bug Some of algorithms are correct, some of algorithms have bug yet. If the algorithm is correct, we can get the output we want of the problem. Otherwise, we won't solve the problem until we fix the bug. 5.3. Time complexity Different algorithms have different efficiencies, time complexity could show the efficiency of algorithms by counting the number of elementary operations performed by algorithm. Concretely, think there is a problem finding someone's number in a phone book sorted alphabetically. Our input is the name of someone we looking for his number, and a phone book sorted alphabetically and contains his number. Our output is the phone number. So, there are three algorithms with varied efficiency. Start from first page, search each name with its phone-number in each page, until we find it. Ditto, but we can find it two pages at a time, if we flipped too far, we have to check it back. Start from the middle page of the phone-book, decide whether our name will be in the left half or right half of the book(since our book is alphabetically), and reduce the size of our problem by half. Repeat until we find our name. In fact, we can represent the efficiency of each of those algorithms with a chart: The efficiency of the third one algorithm is well over the others. That is logarithmic algorithm, since we\u2019re divid ing the problem by two with each step. So when we write programs using algorithms, we not only have to care about whether the algorithm is correct, but also how well-designed it is, considering factors such as efficiency. 6. Pseudocode 6.1. What is Pseudo-code Pseudo-code by definition is not real code , but a representation of our algorithm in precise English(or some other human language u like). Concretely, we can represent the algorithm of the phone-book problem above with pseudo-code: 1 2 3 4 5 6 7 8 9 10 11 12 13 Pick up phone book Open to middle of phone book Look at page If person is on page Call person Else if person is earlier in book Open to middle of left half of book Go back to line 3 Else if person is later in book Open to middle of right half of book Go back to line 3 Else Quit With these steps we can solve the problem easily. But NOTICE that, there is a statement \"Else\" at line 12, this is called \" final case \", which is particularly important to remember, cause it might appear to freeze or stop responding when we forget it , even it can continue to repeat the same work over and over and never stop , just since the algorithm encountered a case that wasn't accounted for. 6.2. Each part of it Notice that some of these lines start with verbs, or actions, such as Pick up , Open to etc. There are functions . We also have branch that lead to different paths like If , Else if etc, like forks in the road, which we'll call conditions . And there are many questions that decide where we go are called Boolean expressions , which eventually result in a value of yes(True) or no(False), as person is on page in line 4. Lastly, we have words that create cycles, where we can repeat parts of our program, this called loops , as Go back to line N in line 8 and 11. 7. Additional features We've found these features of programming in pseudo-code above: Functions Conditions Boolean expressions Loops And we'll discover those additional features yet: Variables Threads Events ...etc 7.1. Hello Problem Think of a problem that ask someone's name, and says \"Hello, someone's name\". The input of this problem is someone's name, and the output is \"Hello,\" and the name. So what's the algorithm of the problem? We can solve it in Scratch , which is a graphical programming language compared to old-fashion programming language like C, that means we can program by dragging and dropping blocks that contain instructions. Now we can design our algorithm with pseudo-code: 1 2 Get name of users with asking \"What's ur name?\" Say \"hello,\" and the name above Or show it with Scratch: 7.2. Variables The answer block in Scratch or the name in pseudo-code is a variable , or value, that stores some values of bit which may mapping to something like numbers, letters and images etc. In this case, this variable stores what the program's user type in, i.e., a sequence of letters of user's name. 7.3. Functions In fact, the line \"Say 'hello,' ...\" in line 1 or the say block itself in Scratch is like an algorithm, where we provide an input of \"What's ur name\" and it produced the output that to print the text of we input. The ask block, too, takes in an input(i.e., the question we want to ask), and produces the output of a variable in that stores the name of we enter. It's not limited that the number of input value, we can input multiple values to it. E.g., we can use the answer block along with our own text, \"Hello, \", as two inputs to the join algorithm(or function) : So, this is functions, which contains algorithms. It takes some input, produce some output by algorithm. 7.4. Loop Loop is repeating something, where our programs achieves the same results, but with fewer codes, which means our code is Well-designed we mentioned before. That because if there's something we wanna change, we would only need to change it in one place instead of lots. Besides, it'll more readable when we back to change it. Also sometimes we need to do something forever and never ever stop it, for instance we wanna the program print the text \"Hello!\" forever. This time we'll need loop , but in order to repeat something never stop. 7.5. Abstraction Abstraction is an important concept in Computer Science. What is abstraction is to simplify a more complex concept. In case, our \"Hello problem\" takes some of input that the name of users', then it would produce the output that print a text of \"Hello\" and user's name. The algorithm of this problem is somewhat complex as we know, it contains lots of functions, which are essentially sub-problems, take some input then make some output with its algorithm. (For instance, the say function, which take words as its input, then print it as the output.) But when we solved the hello problem, we can define it as a hello function, whose input and output is same as the problem before, but we needn't to care about how the algorithm implemented, we just use it like say function. Maybe say function contains some sub-function, just like hello function may contain say function, but whatever, who care about it. That is Abstraction , we can focus on the higher-level of programming via abstraction. Concretely, we could reuse the solution of any problems we've done before, like hello above; or we could use the solution that anybody done, e.g., there is a function read with voice , that take the input is same as hello function's, but its output is reading the text with a human's voice.","title":"Lec 00: Scratch"},{"location":"notes/Harvard_CS50/0x00_Scratch/#1-what-is-computer-science","text":"Computer science is fundamentally problem solving . What is problem solving is as the process of taking some input (i.e., details about our problem), and then generate some output (i.e., the solution to our problem). The black box in the middle is Computer Science, that is the code we'll learn to write. To begin doing that, we'll need a way to represent input and output , so that we can store and work with information in a standardized way .","title":"1. What is computer science?"},{"location":"notes/Harvard_CS50/0x00_Scratch/#2-representing-numbers","text":"","title":"2. Representing numbers"},{"location":"notes/Harvard_CS50/0x00_Scratch/#21-unary","text":"When we counting the number of people in a room, probably we can do it with our hand, that is we raise one finger at a time to represent each person. It's stupid but simple, and we won't be able to count very high. This system is unary , where each digit represents a single value of one.","title":"2.1. Unary"},{"location":"notes/Harvard_CS50/0x00_Scratch/#22-decimal","text":"As we know, we have a more efficient system to represent numbers, where we have 10 digits, 0 through 9. 0 1 2 3 4 5 6 7 8 9 This system is called decimal , or base 10 , since there are 10 different values that a digit can represent.","title":"2.2. Decimal"},{"location":"notes/Harvard_CS50/0x00_Scratch/#23-binary","text":"Computer use a simpler system called binary , or base 2 , with only two possible digits, 0 or 1. Since computer run on electricity , there are two states of an electronic switch, which can be turned on or off. We can conveniently represent a bit by turning a switch on or off to represent a 0 or 1.","title":"2.3. Binary"},{"location":"notes/Harvard_CS50/0x00_Scratch/#3-text","text":"","title":"3. Text"},{"location":"notes/Harvard_CS50/0x00_Scratch/#31-map-and-ascii","text":"Since the computer can only represent number in binary, so if we wanna represent text or a single letter, we need to map the numbers to letters, e.g., 'A' can be mapped to 65, and 65 is a Decimal number, it's 01000001 whose representation of 65 in binary. Fortunately, we needn't to decide the correspondences of each letter mapping. There is a standard mapping, ASCII ( American Standard Code for Information Interchange ), which include the mapping of higher-case, lower letters and punctuation.","title":"3.1. Map and ASCII"},{"location":"notes/Harvard_CS50/0x00_Scratch/#32-one-byte-8-bits","text":"E.g., If we received a text message with a pattern of bits that had a decimal values 72 , 73 and 33 , those would map to the letters HI . Each letter actually is typically represented with a pattern of eight bits , or a byte. So, the sequences of bits we would receive are 01001000 , 01001001 , and 00100001 . Byte is the unit of measurement for data with which we might already be familiar, as in megabytes(MB) or gigabytes(GB), for million or billions of bytes. With eight bits, or one byte, there are 2^8^, or 256 different values (including zero), and the highest value we can count up to would be 255.","title":"3.2. one Byte = 8 Bits"},{"location":"notes/Harvard_CS50/0x00_Scratch/#33-unicode","text":"Can we represent any characters by using one byte? We know one byte have 2^8^ different values, so one byte can represent 2^8^ = 256 characters. Of course it's more than 256 characters that the character of languages all around the world, such as Asian language, Islam language etc. What's more, there are also other characters such as letters with accent marks and symbols. They are part of a more generally standard called Unicode , which uses more bits than ASCII to accommodate all the characters. Concretely, when we receive an emoji, out computer is actually receiving a number in binary that it then maps to the image of the emoji based on Unicode standard. For example, the \"face with tears of joy\" emoji is just the bits 000000011111011000000010 :","title":"3.3. Unicode"},{"location":"notes/Harvard_CS50/0x00_Scratch/#4-images-video-sounds","text":"","title":"4. Images, video, sounds"},{"location":"notes/Harvard_CS50/0x00_Scratch/#41-images","text":"","title":"4.1. Images"},{"location":"notes/Harvard_CS50/0x00_Scratch/#411-rgb","text":"An image, like the picture of the emoji \"face with tears of joy\" above, are made up of colors . We can still represent each color with only bits, just like how we map numbers to letters, we can map numbers to colors as well. There are many different systems to represent colors, but a common one is RGB , which represent a color by indicating the amount of red , blue and green within each color. And our programs would know those bits map to a color if we opened an image file , as opposed to receiving them in a text message(map to letters).","title":"4.1.1 RGB"},{"location":"notes/Harvard_CS50/0x00_Scratch/#412-pixels","text":"We know that there are lots of dots in a photo if we zoom in, e.g., the emoji above: These dots, or squares are called pixels , and image are made up of many thousands or millions of those pixels as well. There are three bits to represent the amount of red, blue and green color in this pixel. For example, if we have received this pattern of bits: 72 , 73 , 33 . That indicate the amount of blue is 72 over 255(a bit has 2^8^ different values ), and so on. So we'll get this eventually:","title":"4.1.2 Pixels"},{"location":"notes/Harvard_CS50/0x00_Scratch/#413-resolution","text":"The resolution of an image is the number of pixels there are, horizontally and vertically. That means more clear image(High-resolution) we get, more pixels it'll have, and then, more bits required to be stored. That explains why the high-resolution image always need more storage.","title":"4.1.3. Resolution"},{"location":"notes/Harvard_CS50/0x00_Scratch/#42-video","text":"Video is a sequence of images, which changing multiple times a second to give us appearance of motion, as an old-fashioned flip-book might do. For us human being, if the images can changing enough multiple times in a second, we cannot discriminate whether it's a sequence of image or a continuous video, with our eyes.","title":"4.2. Video"},{"location":"notes/Harvard_CS50/0x00_Scratch/#43-sounds","text":"Of course music can be represented with bits, with mappings of numbers to notes and durations, or more complex mappings of bits to sound frequencies at each moment of time.","title":"4.3. Sounds"},{"location":"notes/Harvard_CS50/0x00_Scratch/#44-others-files","text":"File formats, like JPEG and PNG, or WORD or EXCEL documents, are also based on some standard that some humans have agreed on, for representing information with bits.","title":"4.4. Others files"},{"location":"notes/Harvard_CS50/0x00_Scratch/#5-algorithms","text":"","title":"5. Algorithms"},{"location":"notes/Harvard_CS50/0x00_Scratch/#51-what-is-algorithms","text":"Now we can represent inputs and outputs with bits, we can concentrate our work on problem solving, where the black box in the middle of the figure before. Algorithms are some step-by-step instructions for solving problem, it's some computings that make the input to the output what we want. Humans can follow algorithms too, such as recipes for cooking. When programming a computer , we need to be more precise with our algorithms so that our instructions aren't ambiguous or misinterpreted.","title":"5.1. What is Algorithms"},{"location":"notes/Harvard_CS50/0x00_Scratch/#52-correct-and-bug","text":"Some of algorithms are correct, some of algorithms have bug yet. If the algorithm is correct, we can get the output we want of the problem. Otherwise, we won't solve the problem until we fix the bug.","title":"5.2. Correct and Bug"},{"location":"notes/Harvard_CS50/0x00_Scratch/#53-time-complexity","text":"Different algorithms have different efficiencies, time complexity could show the efficiency of algorithms by counting the number of elementary operations performed by algorithm. Concretely, think there is a problem finding someone's number in a phone book sorted alphabetically. Our input is the name of someone we looking for his number, and a phone book sorted alphabetically and contains his number. Our output is the phone number. So, there are three algorithms with varied efficiency. Start from first page, search each name with its phone-number in each page, until we find it. Ditto, but we can find it two pages at a time, if we flipped too far, we have to check it back. Start from the middle page of the phone-book, decide whether our name will be in the left half or right half of the book(since our book is alphabetically), and reduce the size of our problem by half. Repeat until we find our name. In fact, we can represent the efficiency of each of those algorithms with a chart: The efficiency of the third one algorithm is well over the others. That is logarithmic algorithm, since we\u2019re divid ing the problem by two with each step. So when we write programs using algorithms, we not only have to care about whether the algorithm is correct, but also how well-designed it is, considering factors such as efficiency.","title":"5.3. Time complexity"},{"location":"notes/Harvard_CS50/0x00_Scratch/#6-pseudocode","text":"","title":"6. Pseudocode"},{"location":"notes/Harvard_CS50/0x00_Scratch/#61-what-is-pseudo-code","text":"Pseudo-code by definition is not real code , but a representation of our algorithm in precise English(or some other human language u like). Concretely, we can represent the algorithm of the phone-book problem above with pseudo-code: 1 2 3 4 5 6 7 8 9 10 11 12 13 Pick up phone book Open to middle of phone book Look at page If person is on page Call person Else if person is earlier in book Open to middle of left half of book Go back to line 3 Else if person is later in book Open to middle of right half of book Go back to line 3 Else Quit With these steps we can solve the problem easily. But NOTICE that, there is a statement \"Else\" at line 12, this is called \" final case \", which is particularly important to remember, cause it might appear to freeze or stop responding when we forget it , even it can continue to repeat the same work over and over and never stop , just since the algorithm encountered a case that wasn't accounted for.","title":"6.1. What is Pseudo-code"},{"location":"notes/Harvard_CS50/0x00_Scratch/#62-each-part-of-it","text":"Notice that some of these lines start with verbs, or actions, such as Pick up , Open to etc. There are functions . We also have branch that lead to different paths like If , Else if etc, like forks in the road, which we'll call conditions . And there are many questions that decide where we go are called Boolean expressions , which eventually result in a value of yes(True) or no(False), as person is on page in line 4. Lastly, we have words that create cycles, where we can repeat parts of our program, this called loops , as Go back to line N in line 8 and 11.","title":"6.2. Each part of it"},{"location":"notes/Harvard_CS50/0x00_Scratch/#7-additional-features","text":"We've found these features of programming in pseudo-code above: Functions Conditions Boolean expressions Loops And we'll discover those additional features yet: Variables Threads Events ...etc","title":"7. Additional features"},{"location":"notes/Harvard_CS50/0x00_Scratch/#71-hello-problem","text":"Think of a problem that ask someone's name, and says \"Hello, someone's name\". The input of this problem is someone's name, and the output is \"Hello,\" and the name. So what's the algorithm of the problem? We can solve it in Scratch , which is a graphical programming language compared to old-fashion programming language like C, that means we can program by dragging and dropping blocks that contain instructions. Now we can design our algorithm with pseudo-code: 1 2 Get name of users with asking \"What's ur name?\" Say \"hello,\" and the name above Or show it with Scratch:","title":"7.1. Hello Problem"},{"location":"notes/Harvard_CS50/0x00_Scratch/#72-variables","text":"The answer block in Scratch or the name in pseudo-code is a variable , or value, that stores some values of bit which may mapping to something like numbers, letters and images etc. In this case, this variable stores what the program's user type in, i.e., a sequence of letters of user's name.","title":"7.2. Variables"},{"location":"notes/Harvard_CS50/0x00_Scratch/#73-functions","text":"In fact, the line \"Say 'hello,' ...\" in line 1 or the say block itself in Scratch is like an algorithm, where we provide an input of \"What's ur name\" and it produced the output that to print the text of we input. The ask block, too, takes in an input(i.e., the question we want to ask), and produces the output of a variable in that stores the name of we enter. It's not limited that the number of input value, we can input multiple values to it. E.g., we can use the answer block along with our own text, \"Hello, \", as two inputs to the join algorithm(or function) : So, this is functions, which contains algorithms. It takes some input, produce some output by algorithm.","title":"7.3. Functions"},{"location":"notes/Harvard_CS50/0x00_Scratch/#74-loop","text":"Loop is repeating something, where our programs achieves the same results, but with fewer codes, which means our code is Well-designed we mentioned before. That because if there's something we wanna change, we would only need to change it in one place instead of lots. Besides, it'll more readable when we back to change it. Also sometimes we need to do something forever and never ever stop it, for instance we wanna the program print the text \"Hello!\" forever. This time we'll need loop , but in order to repeat something never stop.","title":"7.4. Loop"},{"location":"notes/Harvard_CS50/0x00_Scratch/#75-abstraction","text":"Abstraction is an important concept in Computer Science. What is abstraction is to simplify a more complex concept. In case, our \"Hello problem\" takes some of input that the name of users', then it would produce the output that print a text of \"Hello\" and user's name. The algorithm of this problem is somewhat complex as we know, it contains lots of functions, which are essentially sub-problems, take some input then make some output with its algorithm. (For instance, the say function, which take words as its input, then print it as the output.) But when we solved the hello problem, we can define it as a hello function, whose input and output is same as the problem before, but we needn't to care about how the algorithm implemented, we just use it like say function. Maybe say function contains some sub-function, just like hello function may contain say function, but whatever, who care about it. That is Abstraction , we can focus on the higher-level of programming via abstraction. Concretely, we could reuse the solution of any problems we've done before, like hello above; or we could use the solution that anybody done, e.g., there is a function read with voice , that take the input is same as hello function's, but its output is reading the text with a human's voice.","title":"7.5. Abstraction"},{"location":"notes/Harvard_CS50/0x01_C/","text":"1. Three qualities Correctness , or whether our code works correctly, as intended. Design , or a subjective measure of how well-written our code is, based on how efficient it is and how elegant or logically readable it is, without unnecessary repetition. Style , or how aesthetically formatted our code is, in terms of consistent indentation and other placement of symbols. Differences in style don't affect the correctness or meaning of our code, but affect how readable it is visually. 2. Compiling 2.1. Source code v.s. Machine code We'll compile our code before we can run it. Computer can only understand binary , which is also used to represent instructions like print something to the screen. Our source code has been written in characters we can read,(i.e., hello.c ) but it need to be compiled: convert to machine code , patterns of zeros and ones that our computer can directly understand. E.g., hello.c of source code: 1 2 3 4 5 6 #include <stdio.h> int main ( void ) { printf ( \"hello, world\" ); } 2.2. Compiler But how can we convert source code to machine code , there we need is a program called compiler , which will take source code as input and produce machine code as output. For example, in CS50 IDE, the compiler program name is called make , when we type make hello in the terminal of CS50 IDE, it'll automatically find our hello.c file as source code of input, and then convert it to machine code which is actually a executable program called hello , and it's the parameter we input. There will be some output to tell you whether your compiling is successful, if there's no error messages in yellow or red, it's compiled successful. 3. Functions and arguments That's the same ideas we've explored in 0x00 Scratch . We've known that a function is an instance of algorithms, which has an input and an output, where output is produced by its algorithm. We can imagine the functions as small actions or verbs that we can use in our program to do something, which we called abstraction we'll detail it later. 3.1. Arguments The input of functions we called arguments . E.g., the function printf (with the f standing for \"formatted\" text), we pass the arguments with parentheses , as in printf(\"Hello World!\"); , the double quotes indicate that we want to print out the letters hello world literally, and the semicolon at the end indicates the end of our line of code. 3.2. Outputs Functions can also have two kinds of outputs: side effects , such as something printed to screen, or play sound. return value , a value that is passed back to our program that we can use or store for later. (e.g., add(num1, num2) function, which will return the result of addition back to us.) 3.3. Library How can we use the functions we've already written, or the functions the others written? We'll use a library , which is a set of code already written. For example, the cs50 library we already used includes some basic , simple functions that we can use right away.(E,g., get_string ) Before we can use the functions of library, we need to declare it, that is telling the compiler to include the Library we wanna used. 1 2 #include <cs50.h> // tell compiler to include cs50.h #include <stdio.h> 3.4. Escape sequence What is escape sequence is some text that represents some other text probably hard to type. Like \\n in printf(\"hello, world\\n\"); , which represent a newline character. 4. main, header file 4.1. main function Main function is the entrance of the whole program, we'll learn more about it later, for now we'll simply use this to start our program. 1 2 3 4 int main ( void ) { // codes } 4.2. Header files Header files that end with .h refer to some other set of code, like a library, that we can then use in our program. We include them with lines like #include <stdio.h> , which stdio.h standing for the standard input/output library, which contains printf function. 5. Types, format codes 5.1. Types There are many data types we can use for our variables, which indicate to the computer what type of data they represent. bool , a Boolean expression of either true or false char , a single ASCII character like a or 2 double , a floating-point value with more digits than a float float , a floating-point value, or a real-number with a decimal value int , integers up to a certain size, or number of bits long , integers with more bits, so they can count higher than an int string , a string of characters 5.2. Format codes For printf , there are also different placeholders for each type: %c for chars %f for floats, doubles %i , for ints %li , for longs %s , for strings 6. Operators, limitations, truncation 6.1. Operators There are several mathematical operators we can use too: + for addition - for subtracation * for multiplication / for division % for remainder 6.2. Limitations When we get an integer with get_int function, it'll denied our input if it more than 2 billion, or less than minus 2 billion. That's because all the types have its limitations of memory. In this case, the limitation of int is from -2^31^ to 2^31^ - 1 cause like on many computer systems, an int is 32 bits, which can only contain 2^32^ numbers(negative 2^31^ number, positive 2^31^ - 1 numbers and zero). 6.3. Truncation Since each type has its limitation, does these limitations effect the mathematical operation? If we divide an integer by another one, then save the result to a float number, what would happen? The answer is truncation , with the value after the decimal point lost. Even though result is a double , the value we're storing in it is already an integer. 1 2 3 int x = 5 , y = 3 ; double result = x / y ; // result = 1 rather than 1.666667 To fix this, we cast , or convert, out integers to floats before we divide them. 1 float result = ( float ) x / ( float ) y ; Then the result will be a float as we expect, actually we can cast only one of x or y and get a float as well. 7. Variables, syntactic suger 7.1. Variables In C, we would write type name = value; to create a variable and give it some value. 1 int result = 3 ; 7.2. Syntactic suger What is syntactic sugar is shorthand expressions for the same functionality. E.g., we can increase the value of a variable with result = result + 1; , we also could equivalently say result += 1 , we even could just write it as result++ . We can learn this through looking at the documentation or other references online. 8. Conditions We can use conditions in C, that is if , else if , else blocks, with: 1 2 3 4 5 6 7 if ( x < y ){ printf ( \"x is less than y \\n \" ); } else if ( x > y ) { printf ( \"x is greater than y \\n \" ); } else { printf ( \"x is equal to y \\n \" ); } And we could notice that in C we use { and } (as well as indentation) to indicate how lines of code should be nested. We use two vertical bar || to indicate a logical or , two ampersands && to indicate a logical and . Then two equal signs == to compare two values whether it's equal.(Essentially a character is a value, that with two single quotes surrounding it) 9. Boolean expressions, loops 9.1. Boolean expressions Boolean expressions is an expression with the value either true value or false value. 1 2 3 int num1 = 10 ; int num2 = 12 ; // num1 == num2 is FALSE Boolean expressions controls the loops keep running or not. 9.2. Loops Loops requires a condition, and it will check the condition whether it's true, if it is, Loop will run once, and then check again. 10. Abstraction We can reuse out designs, like abstract it to a function. That will make our code more readable. 1 2 3 4 5 6 7 8 9 10 11 #include <stdio.h> int main ( void ){ printf ( \"meow \\n \" ); printf ( \"meow \\n \" ); printf ( \"meow \\n \" ); // or meow ( 3 ); } By using abstraction, we could concentrate on more high-level, and reduce repetition of codes. 11. Memory, imprecision, and overflow 11.1. Memory Our computer has memory, in hardware chips called RAM , random-access memory. Our programs use RAM to store data while they're running, BUT that memory is finite . 11.2. Imprecision Because RAM is finite, it will cause imprecision: 1 2 3 4 5 6 7 8 9 #include <cs50.h> #include <stdio.h> int main ( void ){ float x = 1 ; float y = 10 ; printf ( \"%.50f \\n \" , x / y ); } // result : 0.10000000149011611938476562500000000000000000000000 It turns out that is called float-point imprecision , where we don't have enough bits to store all possible values. With a finite number of bits for a float , we can't represent all possible real numbers (of which there are an infinite number of), so the computer has to store the closest value it can. 11.3. Overflow If we only have three bits and need to count higher than seven ( 111 ), we add another bit to get eight, 1000 . But if we only have three bits available, we won't have a place for extra 1 . It will disappear and we will be back at 000 . This problem is called integer overflow , where an integer can only be so big before it runs out of bits.","title":"Lec 01: C"},{"location":"notes/Harvard_CS50/0x01_C/#1-three-qualities","text":"Correctness , or whether our code works correctly, as intended. Design , or a subjective measure of how well-written our code is, based on how efficient it is and how elegant or logically readable it is, without unnecessary repetition. Style , or how aesthetically formatted our code is, in terms of consistent indentation and other placement of symbols. Differences in style don't affect the correctness or meaning of our code, but affect how readable it is visually.","title":"1. Three qualities"},{"location":"notes/Harvard_CS50/0x01_C/#2-compiling","text":"","title":"2. Compiling"},{"location":"notes/Harvard_CS50/0x01_C/#21-source-code-vs-machine-code","text":"We'll compile our code before we can run it. Computer can only understand binary , which is also used to represent instructions like print something to the screen. Our source code has been written in characters we can read,(i.e., hello.c ) but it need to be compiled: convert to machine code , patterns of zeros and ones that our computer can directly understand. E.g., hello.c of source code: 1 2 3 4 5 6 #include <stdio.h> int main ( void ) { printf ( \"hello, world\" ); }","title":"2.1. Source code v.s. Machine code"},{"location":"notes/Harvard_CS50/0x01_C/#22-compiler","text":"But how can we convert source code to machine code , there we need is a program called compiler , which will take source code as input and produce machine code as output. For example, in CS50 IDE, the compiler program name is called make , when we type make hello in the terminal of CS50 IDE, it'll automatically find our hello.c file as source code of input, and then convert it to machine code which is actually a executable program called hello , and it's the parameter we input. There will be some output to tell you whether your compiling is successful, if there's no error messages in yellow or red, it's compiled successful.","title":"2.2. Compiler"},{"location":"notes/Harvard_CS50/0x01_C/#3-functions-and-arguments","text":"That's the same ideas we've explored in 0x00 Scratch . We've known that a function is an instance of algorithms, which has an input and an output, where output is produced by its algorithm. We can imagine the functions as small actions or verbs that we can use in our program to do something, which we called abstraction we'll detail it later.","title":"3. Functions and arguments"},{"location":"notes/Harvard_CS50/0x01_C/#31-arguments","text":"The input of functions we called arguments . E.g., the function printf (with the f standing for \"formatted\" text), we pass the arguments with parentheses , as in printf(\"Hello World!\"); , the double quotes indicate that we want to print out the letters hello world literally, and the semicolon at the end indicates the end of our line of code.","title":"3.1. Arguments"},{"location":"notes/Harvard_CS50/0x01_C/#32-outputs","text":"Functions can also have two kinds of outputs: side effects , such as something printed to screen, or play sound. return value , a value that is passed back to our program that we can use or store for later. (e.g., add(num1, num2) function, which will return the result of addition back to us.)","title":"3.2. Outputs"},{"location":"notes/Harvard_CS50/0x01_C/#33-library","text":"How can we use the functions we've already written, or the functions the others written? We'll use a library , which is a set of code already written. For example, the cs50 library we already used includes some basic , simple functions that we can use right away.(E,g., get_string ) Before we can use the functions of library, we need to declare it, that is telling the compiler to include the Library we wanna used. 1 2 #include <cs50.h> // tell compiler to include cs50.h #include <stdio.h>","title":"3.3. Library"},{"location":"notes/Harvard_CS50/0x01_C/#34-escape-sequence","text":"What is escape sequence is some text that represents some other text probably hard to type. Like \\n in printf(\"hello, world\\n\"); , which represent a newline character.","title":"3.4. Escape sequence"},{"location":"notes/Harvard_CS50/0x01_C/#4-main-header-file","text":"","title":"4. main, header file"},{"location":"notes/Harvard_CS50/0x01_C/#41-main-function","text":"Main function is the entrance of the whole program, we'll learn more about it later, for now we'll simply use this to start our program. 1 2 3 4 int main ( void ) { // codes }","title":"4.1. main function"},{"location":"notes/Harvard_CS50/0x01_C/#42-header-files","text":"Header files that end with .h refer to some other set of code, like a library, that we can then use in our program. We include them with lines like #include <stdio.h> , which stdio.h standing for the standard input/output library, which contains printf function.","title":"4.2. Header files"},{"location":"notes/Harvard_CS50/0x01_C/#5-types-format-codes","text":"","title":"5. Types, format codes"},{"location":"notes/Harvard_CS50/0x01_C/#51-types","text":"There are many data types we can use for our variables, which indicate to the computer what type of data they represent. bool , a Boolean expression of either true or false char , a single ASCII character like a or 2 double , a floating-point value with more digits than a float float , a floating-point value, or a real-number with a decimal value int , integers up to a certain size, or number of bits long , integers with more bits, so they can count higher than an int string , a string of characters","title":"5.1. Types"},{"location":"notes/Harvard_CS50/0x01_C/#52-format-codes","text":"For printf , there are also different placeholders for each type: %c for chars %f for floats, doubles %i , for ints %li , for longs %s , for strings","title":"5.2. Format codes"},{"location":"notes/Harvard_CS50/0x01_C/#6-operators-limitations-truncation","text":"","title":"6. Operators, limitations, truncation"},{"location":"notes/Harvard_CS50/0x01_C/#61-operators","text":"There are several mathematical operators we can use too: + for addition - for subtracation * for multiplication / for division % for remainder","title":"6.1. Operators"},{"location":"notes/Harvard_CS50/0x01_C/#62-limitations","text":"When we get an integer with get_int function, it'll denied our input if it more than 2 billion, or less than minus 2 billion. That's because all the types have its limitations of memory. In this case, the limitation of int is from -2^31^ to 2^31^ - 1 cause like on many computer systems, an int is 32 bits, which can only contain 2^32^ numbers(negative 2^31^ number, positive 2^31^ - 1 numbers and zero).","title":"6.2. Limitations"},{"location":"notes/Harvard_CS50/0x01_C/#63-truncation","text":"Since each type has its limitation, does these limitations effect the mathematical operation? If we divide an integer by another one, then save the result to a float number, what would happen? The answer is truncation , with the value after the decimal point lost. Even though result is a double , the value we're storing in it is already an integer. 1 2 3 int x = 5 , y = 3 ; double result = x / y ; // result = 1 rather than 1.666667 To fix this, we cast , or convert, out integers to floats before we divide them. 1 float result = ( float ) x / ( float ) y ; Then the result will be a float as we expect, actually we can cast only one of x or y and get a float as well.","title":"6.3. Truncation"},{"location":"notes/Harvard_CS50/0x01_C/#7-variables-syntactic-suger","text":"","title":"7. Variables, syntactic suger"},{"location":"notes/Harvard_CS50/0x01_C/#71-variables","text":"In C, we would write type name = value; to create a variable and give it some value. 1 int result = 3 ;","title":"7.1. Variables"},{"location":"notes/Harvard_CS50/0x01_C/#72-syntactic-suger","text":"What is syntactic sugar is shorthand expressions for the same functionality. E.g., we can increase the value of a variable with result = result + 1; , we also could equivalently say result += 1 , we even could just write it as result++ . We can learn this through looking at the documentation or other references online.","title":"7.2. Syntactic suger"},{"location":"notes/Harvard_CS50/0x01_C/#8-conditions","text":"We can use conditions in C, that is if , else if , else blocks, with: 1 2 3 4 5 6 7 if ( x < y ){ printf ( \"x is less than y \\n \" ); } else if ( x > y ) { printf ( \"x is greater than y \\n \" ); } else { printf ( \"x is equal to y \\n \" ); } And we could notice that in C we use { and } (as well as indentation) to indicate how lines of code should be nested. We use two vertical bar || to indicate a logical or , two ampersands && to indicate a logical and . Then two equal signs == to compare two values whether it's equal.(Essentially a character is a value, that with two single quotes surrounding it)","title":"8. Conditions"},{"location":"notes/Harvard_CS50/0x01_C/#9-boolean-expressions-loops","text":"","title":"9. Boolean expressions, loops"},{"location":"notes/Harvard_CS50/0x01_C/#91-boolean-expressions","text":"Boolean expressions is an expression with the value either true value or false value. 1 2 3 int num1 = 10 ; int num2 = 12 ; // num1 == num2 is FALSE Boolean expressions controls the loops keep running or not.","title":"9.1. Boolean expressions"},{"location":"notes/Harvard_CS50/0x01_C/#92-loops","text":"Loops requires a condition, and it will check the condition whether it's true, if it is, Loop will run once, and then check again.","title":"9.2. Loops"},{"location":"notes/Harvard_CS50/0x01_C/#10-abstraction","text":"We can reuse out designs, like abstract it to a function. That will make our code more readable. 1 2 3 4 5 6 7 8 9 10 11 #include <stdio.h> int main ( void ){ printf ( \"meow \\n \" ); printf ( \"meow \\n \" ); printf ( \"meow \\n \" ); // or meow ( 3 ); } By using abstraction, we could concentrate on more high-level, and reduce repetition of codes.","title":"10. Abstraction"},{"location":"notes/Harvard_CS50/0x01_C/#11-memory-imprecision-and-overflow","text":"","title":"11. Memory, imprecision, and overflow"},{"location":"notes/Harvard_CS50/0x01_C/#111-memory","text":"Our computer has memory, in hardware chips called RAM , random-access memory. Our programs use RAM to store data while they're running, BUT that memory is finite .","title":"11.1. Memory"},{"location":"notes/Harvard_CS50/0x01_C/#112-imprecision","text":"Because RAM is finite, it will cause imprecision: 1 2 3 4 5 6 7 8 9 #include <cs50.h> #include <stdio.h> int main ( void ){ float x = 1 ; float y = 10 ; printf ( \"%.50f \\n \" , x / y ); } // result : 0.10000000149011611938476562500000000000000000000000 It turns out that is called float-point imprecision , where we don't have enough bits to store all possible values. With a finite number of bits for a float , we can't represent all possible real numbers (of which there are an infinite number of), so the computer has to store the closest value it can.","title":"11.2. Imprecision"},{"location":"notes/Harvard_CS50/0x01_C/#113-overflow","text":"If we only have three bits and need to count higher than seven ( 111 ), we add another bit to get eight, 1000 . But if we only have three bits available, we won't have a place for extra 1 . It will disappear and we will be back at 000 . This problem is called integer overflow , where an integer can only be so big before it runs out of bits.","title":"11.3. Overflow"},{"location":"notes/Harvard_CS50/0x02_Arrays/","text":"1. Compiling 1.1. Compiler program Last time, we compiled program with make hello , which turning our source code into machine code so that we could run the complied program with ./hello . Make is actually just a program called clang , a compiler , with options . If we enter clang hello.c , then clang would compile it then make a compiled program named a.out which is the default output filename of clang . So we can run a more specific command: clang hello -o hello.out . 1.2. Command-line argument What is -o hello.out in the command we've just run is called command-line argument , which is an input to a program on the command-line as extra words after program's name. clang is the program name as the first word in command, and then are additional arguments, which are -o , hello.out and hello . That means we're telling the clang to use hello as the source code, and use hello as the output filename. If we want to use CS50's library, via #include <cs50.h> , for the get_string function, we need to add a flag: clang hello -o hello.c -l cs50 . 1 2 3 4 5 6 7 #include <stdio.h> #include <cs50.h> int main () { string name = get_string ( \"What's ur name?\" ); printf ( \"hello, %s \\n \" , name ); } The -l flag links the cs50 file, which includes the machine code for get_string (among other functions), so that our program can then refer to and use as well. With make program, these arguments are generated for us since the staff has configured make in the CS50 IDE already as well. 1.3. Smaller steps of compiling Actually there are four steps under compiling source code into machine code. Preprocessing Compiling Assembling Linking 1.3.1. Preprocessing Preprocessing generally involves lines that start with a # , like #include . For example, #include <cs50.h> will tell clang to look for that header file, since it contains that we want to include in our program. Then, clang will essentially replace the contents of those header files into our program. For example: 1 2 3 4 5 6 7 #include <stdio.h> #include <cs50.h> int main ( void ) { string name = get_string ( \"What's your name? \" ); printf ( \"hello, %s \\n \" , name ); } ...will be preprocessed into: 1 2 3 4 5 6 7 8 9 ... string get_string ( string prompt ); int printf ( string format , ...); ... int main ( void ) { string name = get_string ( \"What's your name? \" ); printf ( \"hello, %s \\n \" , name ); } This includes the prototypes of all the functions from those libraries we included, so we can then use them in our code. 1.3.2. Compiling Compiling takes our source code, in C, and converts it to another type of source code called assembly code , which looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ... main: # @main .cfi_startproc # BB#0: pushq %rbp .Ltmp0: .cfi_def_cfa_offset 16 .Ltmp1: .cfi_offset %rbp, -16 movq %rsp, %rbp .Ltmp2: .cfi_def_cfa_register %rbp subq $16, %rsp xorl %eax, %eax movl %eax, %edi movabsq $.L.str, %rsi movb $0, %al callq get_string movabsq $.L.str.1, %rdi movq %rax, -8(%rbp) movq -8(%rbp), %rsi movb $0, %al callq printf ... These instructions are lower-level and is closer to the binary instructions that a computer's processor can directly understand. They generally operate on bytes themselves, as opposed to abstractions like variable names. 1.3.3. Assembling The next step after compiling is assembling , which takes the assembly code and translate it to instructions in binary. The instructions in binary are called machine code , which a computer's CPU can run directly, 1.3.4. Linking The last step is linking , where previously compiled versions of libraries that we included earlier, like cs50.c , are actually combined with the binary of our program. So we end up with one binary file, a.out or hello , that is the combined machine code for hello.c , cs50.c and stdio.c .(In the CS50 IDE, precompiled machine code for cs50.c and stdio.c has already been installed, and clang has been configured to find and use them.) These four steps have been abstracted away, or simplified, by make , so all well we have to implement is the code for our programs. 2. Debugging 2.1. Bugs Bugs are mistakes or problems in programs that cause them to behave differently than intended. For example, let's take a look at buggy0.c : 1 2 3 4 5 6 7 8 #include <stdio.h> int main ( void ) { // Print 10 hashes for ( int i = 0 ; i <= 10 ; i ++ ) { printf ( \"# \\n \" ); } } What we want is to print just 10 hashes, but it print 11 hashes, which behave differently than we intended. 2.2. Printf Since this program is compiling without any errors, so we now have a logical error. Printf is a useful also simple tool for debugging, which we known it's a function in the library of stdio . We can simply add another printf temporarily: 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { // Print 10 hashes for ( int i = 0 ; i <= 10 ; i ++ ) { printf ( \"i is now %i \\n \" , i ); printf ( \"# \\n \" ); } } Then we can see what value of i is, it started at 0 and continued until it was 10, which sum of counts is 11 instead of 10 as we intended. So the problem is caused by the conditional expression of for loop, we should use i < 10 instead of i <= 10 . 2.3. Debuggers In the CS50 IDE, we have another tool, debug50 , to help us debug programs. This is a tool written by staff that's built on a standard tool called gdb . Both of these debuggers are programs that will run our own programs step-by-step and let us look at variables and other information while our program is running. We'll run the command debug50 ./buggy0 , and it will tell us to recompile our program since we changed it. Then it'll tell us to add a breakpoint , or indicator for a line of code where debugger should pause our program. 2.4. Duck debugger We can also use ddb , short for \"duck debugger\", a real technique where we explain what we're trying to do to a rubber duck, and oftentimes we'll realize our own mistake in logic or implementation as we're explaining it. 3. Memory 3.1. Spaces of different types In C, we have different types of variables we can use for storing data , and each of them take up a fixed amount of space. Different computer systems actually vary in the amount of space actually used for each type, but we'll work with the amounts here, as used in the CS50 IDE. bool 1 byte char 1 byte double 8 bytes float 4 bytes int 4 bytes long 8 bytes string ? bytes ... 3.2. RAM v.s. Hard Drive RAM is a chip insider our computer, short for random-access memory , that stores data for short-term use, like a program's code while it's running, or a file while it's open. We might save a program or file to our hard drive (or SSD, solid state drive) for long-term storage , but use RAM because it's much faster . However, RAM is volatile , or requires power to keep data stored. 3.3. Bytes in RAM We can think of bytes stored in RAM as though they were in a grid : In reality, there are millions(1e6) or billions(1e9) of bytes per chip. Each bytes will have a location on the chip, like the first byte, second byte, and so on. In C, when we create a variable of type char , which will be sized one byte, it will physically be stored in one of those boxes in RAM. An integer as the type of int with 4 bytes, will take up four of those boxes. 4. Arrays 4.1. What is Arrays It turns out, in memory, we can store variable one after another, back-to-back, and access them more easily with loops. In C, a list of values stored one after another contiguously is called an array . 4.2. Access arrays We can assign and use variables in an array with array[index] = value . With the brackets, we're indexing into, or going to, the \"0th\" position in the array. Arrays are zero-indexed , which meaning that the first value has index 0, and then the second value has index 1, and so on. 4.3. Create Arrays When we create or declare an array, we need an integer value to represent the length of array. E.g., int array[3]; . Conveniently, we could use a constant , or variable with a fixed value to replace this integer value. I.e., 1 2 3 4 5 const int LENGTH = 3 ; int main ( void ) { int array [ LENGTH ]; } The keyword const is to tell the compiler that the value of this variable should never be changed by our program. And by convention, we'll place our declaration outside of the main function and capitalize its name, which isn't necessary for the compiler but shows other humans that this variable is a constant and makes it easy to see from the start. 5. Characters 5.1. Char as an integer If we print out a single character like this way: 1 2 char c = '#' ; printf ( \"%c\" , c ); We'll get # printed in the terminal. But if we change it to print c as an integer: 1 2 char c = '#' ; printf ( \"%i\" , ( int ) c ); We get 35 printed. It turns out that 35 is indeed the ASCII code for a # symbol. And in fact, we don't need to cast a char to an integer explicitly when we print a char as an integer, the compiler can do that for us in this case. 1 2 char c = '#' ; printf ( \"%i\" , c ); // still printed 35 5.2. Char in memory A char is a single byte as we mentioned in 3.1, so we can picture it as being stored in one box in the grid of memory above. 6. Strings 6.1. String as an array of chars String is a text, or some characters. We already know that characters are stored in memory taking one byte storing some value. E.g., HI! is representing like this in memory: Strings are actually just arrays of characters, and defined not in C but by the CS50 library. If we had an array called s , each character can be accessed with s[0] . 6.2. Difference between String and arrays of chars The same text HI! , there is a difference between them. It turns out that a string ends with a special character , \\0 , or a byte with all bits set to 0. This character is called the NULL character , or NUL. Therefore, we actually need one more byte than an array of chars to store same text. If we print out each char of string as integer, we'll get that 72 73 33 0 as we expected. And in fact, we could try to access s[4] which should not be accessed by us and even may not existence, but we still can see some unexpected symbol printed. With C, our code has the ability to access or change memory that it otherwise shouldn't, which is both powerful and dangerous. 6.3. Arrays of Strings We can also declare an array of strings, which we can understand it as the array of text, also as two-dimensional arrays of characters. 1 2 3 string words [ 2 ]; words [ 0 ] = \"HI!\" ; words [ 1 ] = \"BYE!\" ; And in memory, the array of strings might be stored and accessed with: words[0] refers to the first element, or value, of the words array, which is a string, and so words[0][0] refers to the first element in that string, which is a character. So an array of strings can be understood as an array of arrays of characters, which also called two-dimensional arrays of characters. There're some useful functions of strings, such as strlen() in string.h , and toupper() in ctype.h . 7. Command-line arguments 7.1. argc and argv Programs of our own can also take in command-line arguments, or words added after our program's name in the command itself. In argv.c , we change what our main function looks like: 1 2 3 4 5 6 7 8 9 10 #include <cs50.h> #include <stdio.h> int main ( int argc , string argv []) { // instead of void if ( argc == 2 ) { printf ( \"hello, %s \\n \" , argv [ 1 ]); } else { printf ( \"hello, world \\n \" ); } } argc and argv are two variables that our main function will now get automatically when our program is run from command line. argv is the short form for argument count , and argv , which is argument list (or argument list), is an array of strings. The first argument is argv[0] , which is the name of our program (the first word typed, like ./hello ). In this example, we check if we have two arguments, and print out the second one if so. E.g., if we run ./argv Lee , we'll get hello, Lee printed, since we typed in Lee as the second word in our command. 7.2. Return value It turns out that our main function also returns an integer value . By default, our main function returns 0 to indicate nothing went wrong, but we can write a program to return a different value: 1 2 3 4 5 6 7 8 9 10 11 #include <stdio.h> #include <cs50.h> int main ( int argc , string argv []) { if ( argc != 2 ) { printf ( \"Missing command-line argument! \\n \" ); return 1 ; } printf ( \"Hello, %s \\n \" , argv [ 1 ]); return 0 ; } The return value of main in our program is called an exit code , usually used to indicate error codes. (We'll write return 0 explicitly at the end of our program here, even though we don't technically need to.) As we write more complex programs, error codes like this can help us determine what went wrong, even if it's not visible or meaningful to the user. 8. Applications Now that we know how to work with strings in our programs, as well code written by others in libraries, we can analyze paragraphs of text for their level of readability, based on factors like how long and complicated the words and sentences are. 8.1. Cryptography Cryptography is the art of scrambling, or hiding information. If we wanted to send a message to someone, we might want to encrypt , or somehow scramble that massage so that it would be hard for others to read. The original message, or input to out algorithm, in called plain-text , and the encrypted message, or output, is called cipher-text . And the algorithm that does the scrambling is called a cipher . A cipher generally requires another input in addition to the plain-text, which called Key , like a number, is some other input that is kept secret. 8.2. Example of Cryptography If we wanted to send a message like I LOVE YOU , we can first convert it to ASCII: 73 76 79 86 69 89 79 85 . Then, we can encrypt it with a key of just 1 and a simple algorithm , where we just add the key to each value: 74 77 80 87 70 90 80 86 . Then, the cipher-text after we convert the values back to ASCII would be J MPWF ZPV . To decrypt this, someone would have to know the key is 1 , and to subtract it from each character,","title":"Lec 02: Arrays"},{"location":"notes/Harvard_CS50/0x02_Arrays/#1-compiling","text":"","title":"1. Compiling"},{"location":"notes/Harvard_CS50/0x02_Arrays/#11-compiler-program","text":"Last time, we compiled program with make hello , which turning our source code into machine code so that we could run the complied program with ./hello . Make is actually just a program called clang , a compiler , with options . If we enter clang hello.c , then clang would compile it then make a compiled program named a.out which is the default output filename of clang . So we can run a more specific command: clang hello -o hello.out .","title":"1.1. Compiler program"},{"location":"notes/Harvard_CS50/0x02_Arrays/#12-command-line-argument","text":"What is -o hello.out in the command we've just run is called command-line argument , which is an input to a program on the command-line as extra words after program's name. clang is the program name as the first word in command, and then are additional arguments, which are -o , hello.out and hello . That means we're telling the clang to use hello as the source code, and use hello as the output filename. If we want to use CS50's library, via #include <cs50.h> , for the get_string function, we need to add a flag: clang hello -o hello.c -l cs50 . 1 2 3 4 5 6 7 #include <stdio.h> #include <cs50.h> int main () { string name = get_string ( \"What's ur name?\" ); printf ( \"hello, %s \\n \" , name ); } The -l flag links the cs50 file, which includes the machine code for get_string (among other functions), so that our program can then refer to and use as well. With make program, these arguments are generated for us since the staff has configured make in the CS50 IDE already as well.","title":"1.2. Command-line argument"},{"location":"notes/Harvard_CS50/0x02_Arrays/#13-smaller-steps-of-compiling","text":"Actually there are four steps under compiling source code into machine code. Preprocessing Compiling Assembling Linking","title":"1.3. Smaller steps of compiling"},{"location":"notes/Harvard_CS50/0x02_Arrays/#131-preprocessing","text":"Preprocessing generally involves lines that start with a # , like #include . For example, #include <cs50.h> will tell clang to look for that header file, since it contains that we want to include in our program. Then, clang will essentially replace the contents of those header files into our program. For example: 1 2 3 4 5 6 7 #include <stdio.h> #include <cs50.h> int main ( void ) { string name = get_string ( \"What's your name? \" ); printf ( \"hello, %s \\n \" , name ); } ...will be preprocessed into: 1 2 3 4 5 6 7 8 9 ... string get_string ( string prompt ); int printf ( string format , ...); ... int main ( void ) { string name = get_string ( \"What's your name? \" ); printf ( \"hello, %s \\n \" , name ); } This includes the prototypes of all the functions from those libraries we included, so we can then use them in our code.","title":"1.3.1. Preprocessing"},{"location":"notes/Harvard_CS50/0x02_Arrays/#132-compiling","text":"Compiling takes our source code, in C, and converts it to another type of source code called assembly code , which looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ... main: # @main .cfi_startproc # BB#0: pushq %rbp .Ltmp0: .cfi_def_cfa_offset 16 .Ltmp1: .cfi_offset %rbp, -16 movq %rsp, %rbp .Ltmp2: .cfi_def_cfa_register %rbp subq $16, %rsp xorl %eax, %eax movl %eax, %edi movabsq $.L.str, %rsi movb $0, %al callq get_string movabsq $.L.str.1, %rdi movq %rax, -8(%rbp) movq -8(%rbp), %rsi movb $0, %al callq printf ... These instructions are lower-level and is closer to the binary instructions that a computer's processor can directly understand. They generally operate on bytes themselves, as opposed to abstractions like variable names.","title":"1.3.2. Compiling"},{"location":"notes/Harvard_CS50/0x02_Arrays/#133-assembling","text":"The next step after compiling is assembling , which takes the assembly code and translate it to instructions in binary. The instructions in binary are called machine code , which a computer's CPU can run directly,","title":"1.3.3. Assembling"},{"location":"notes/Harvard_CS50/0x02_Arrays/#134-linking","text":"The last step is linking , where previously compiled versions of libraries that we included earlier, like cs50.c , are actually combined with the binary of our program. So we end up with one binary file, a.out or hello , that is the combined machine code for hello.c , cs50.c and stdio.c .(In the CS50 IDE, precompiled machine code for cs50.c and stdio.c has already been installed, and clang has been configured to find and use them.) These four steps have been abstracted away, or simplified, by make , so all well we have to implement is the code for our programs.","title":"1.3.4. Linking"},{"location":"notes/Harvard_CS50/0x02_Arrays/#2-debugging","text":"","title":"2. Debugging"},{"location":"notes/Harvard_CS50/0x02_Arrays/#21-bugs","text":"Bugs are mistakes or problems in programs that cause them to behave differently than intended. For example, let's take a look at buggy0.c : 1 2 3 4 5 6 7 8 #include <stdio.h> int main ( void ) { // Print 10 hashes for ( int i = 0 ; i <= 10 ; i ++ ) { printf ( \"# \\n \" ); } } What we want is to print just 10 hashes, but it print 11 hashes, which behave differently than we intended.","title":"2.1. Bugs"},{"location":"notes/Harvard_CS50/0x02_Arrays/#22-printf","text":"Since this program is compiling without any errors, so we now have a logical error. Printf is a useful also simple tool for debugging, which we known it's a function in the library of stdio . We can simply add another printf temporarily: 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { // Print 10 hashes for ( int i = 0 ; i <= 10 ; i ++ ) { printf ( \"i is now %i \\n \" , i ); printf ( \"# \\n \" ); } } Then we can see what value of i is, it started at 0 and continued until it was 10, which sum of counts is 11 instead of 10 as we intended. So the problem is caused by the conditional expression of for loop, we should use i < 10 instead of i <= 10 .","title":"2.2. Printf"},{"location":"notes/Harvard_CS50/0x02_Arrays/#23-debuggers","text":"In the CS50 IDE, we have another tool, debug50 , to help us debug programs. This is a tool written by staff that's built on a standard tool called gdb . Both of these debuggers are programs that will run our own programs step-by-step and let us look at variables and other information while our program is running. We'll run the command debug50 ./buggy0 , and it will tell us to recompile our program since we changed it. Then it'll tell us to add a breakpoint , or indicator for a line of code where debugger should pause our program.","title":"2.3. Debuggers"},{"location":"notes/Harvard_CS50/0x02_Arrays/#24-duck-debugger","text":"We can also use ddb , short for \"duck debugger\", a real technique where we explain what we're trying to do to a rubber duck, and oftentimes we'll realize our own mistake in logic or implementation as we're explaining it.","title":"2.4. Duck debugger"},{"location":"notes/Harvard_CS50/0x02_Arrays/#3-memory","text":"","title":"3. Memory"},{"location":"notes/Harvard_CS50/0x02_Arrays/#31-spaces-of-different-types","text":"In C, we have different types of variables we can use for storing data , and each of them take up a fixed amount of space. Different computer systems actually vary in the amount of space actually used for each type, but we'll work with the amounts here, as used in the CS50 IDE. bool 1 byte char 1 byte double 8 bytes float 4 bytes int 4 bytes long 8 bytes string ? bytes ...","title":"3.1. Spaces of different types"},{"location":"notes/Harvard_CS50/0x02_Arrays/#32-ram-vs-hard-drive","text":"RAM is a chip insider our computer, short for random-access memory , that stores data for short-term use, like a program's code while it's running, or a file while it's open. We might save a program or file to our hard drive (or SSD, solid state drive) for long-term storage , but use RAM because it's much faster . However, RAM is volatile , or requires power to keep data stored.","title":"3.2. RAM v.s. Hard Drive"},{"location":"notes/Harvard_CS50/0x02_Arrays/#33-bytes-in-ram","text":"We can think of bytes stored in RAM as though they were in a grid : In reality, there are millions(1e6) or billions(1e9) of bytes per chip. Each bytes will have a location on the chip, like the first byte, second byte, and so on. In C, when we create a variable of type char , which will be sized one byte, it will physically be stored in one of those boxes in RAM. An integer as the type of int with 4 bytes, will take up four of those boxes.","title":"3.3. Bytes in RAM"},{"location":"notes/Harvard_CS50/0x02_Arrays/#4-arrays","text":"","title":"4. Arrays"},{"location":"notes/Harvard_CS50/0x02_Arrays/#41-what-is-arrays","text":"It turns out, in memory, we can store variable one after another, back-to-back, and access them more easily with loops. In C, a list of values stored one after another contiguously is called an array .","title":"4.1. What is Arrays"},{"location":"notes/Harvard_CS50/0x02_Arrays/#42-access-arrays","text":"We can assign and use variables in an array with array[index] = value . With the brackets, we're indexing into, or going to, the \"0th\" position in the array. Arrays are zero-indexed , which meaning that the first value has index 0, and then the second value has index 1, and so on.","title":"4.2. Access arrays"},{"location":"notes/Harvard_CS50/0x02_Arrays/#43-create-arrays","text":"When we create or declare an array, we need an integer value to represent the length of array. E.g., int array[3]; . Conveniently, we could use a constant , or variable with a fixed value to replace this integer value. I.e., 1 2 3 4 5 const int LENGTH = 3 ; int main ( void ) { int array [ LENGTH ]; } The keyword const is to tell the compiler that the value of this variable should never be changed by our program. And by convention, we'll place our declaration outside of the main function and capitalize its name, which isn't necessary for the compiler but shows other humans that this variable is a constant and makes it easy to see from the start.","title":"4.3. Create Arrays"},{"location":"notes/Harvard_CS50/0x02_Arrays/#5-characters","text":"","title":"5. Characters"},{"location":"notes/Harvard_CS50/0x02_Arrays/#51-char-as-an-integer","text":"If we print out a single character like this way: 1 2 char c = '#' ; printf ( \"%c\" , c ); We'll get # printed in the terminal. But if we change it to print c as an integer: 1 2 char c = '#' ; printf ( \"%i\" , ( int ) c ); We get 35 printed. It turns out that 35 is indeed the ASCII code for a # symbol. And in fact, we don't need to cast a char to an integer explicitly when we print a char as an integer, the compiler can do that for us in this case. 1 2 char c = '#' ; printf ( \"%i\" , c ); // still printed 35","title":"5.1. Char as an integer"},{"location":"notes/Harvard_CS50/0x02_Arrays/#52-char-in-memory","text":"A char is a single byte as we mentioned in 3.1, so we can picture it as being stored in one box in the grid of memory above.","title":"5.2. Char in memory"},{"location":"notes/Harvard_CS50/0x02_Arrays/#6-strings","text":"","title":"6. Strings"},{"location":"notes/Harvard_CS50/0x02_Arrays/#61-string-as-an-array-of-chars","text":"String is a text, or some characters. We already know that characters are stored in memory taking one byte storing some value. E.g., HI! is representing like this in memory: Strings are actually just arrays of characters, and defined not in C but by the CS50 library. If we had an array called s , each character can be accessed with s[0] .","title":"6.1. String as an array of chars"},{"location":"notes/Harvard_CS50/0x02_Arrays/#62-difference-between-string-and-arrays-of-chars","text":"The same text HI! , there is a difference between them. It turns out that a string ends with a special character , \\0 , or a byte with all bits set to 0. This character is called the NULL character , or NUL. Therefore, we actually need one more byte than an array of chars to store same text. If we print out each char of string as integer, we'll get that 72 73 33 0 as we expected. And in fact, we could try to access s[4] which should not be accessed by us and even may not existence, but we still can see some unexpected symbol printed. With C, our code has the ability to access or change memory that it otherwise shouldn't, which is both powerful and dangerous.","title":"6.2. Difference between String and arrays of chars"},{"location":"notes/Harvard_CS50/0x02_Arrays/#63-arrays-of-strings","text":"We can also declare an array of strings, which we can understand it as the array of text, also as two-dimensional arrays of characters. 1 2 3 string words [ 2 ]; words [ 0 ] = \"HI!\" ; words [ 1 ] = \"BYE!\" ; And in memory, the array of strings might be stored and accessed with: words[0] refers to the first element, or value, of the words array, which is a string, and so words[0][0] refers to the first element in that string, which is a character. So an array of strings can be understood as an array of arrays of characters, which also called two-dimensional arrays of characters. There're some useful functions of strings, such as strlen() in string.h , and toupper() in ctype.h .","title":"6.3. Arrays of Strings"},{"location":"notes/Harvard_CS50/0x02_Arrays/#7-command-line-arguments","text":"","title":"7. Command-line arguments"},{"location":"notes/Harvard_CS50/0x02_Arrays/#71-argc-and-argv","text":"Programs of our own can also take in command-line arguments, or words added after our program's name in the command itself. In argv.c , we change what our main function looks like: 1 2 3 4 5 6 7 8 9 10 #include <cs50.h> #include <stdio.h> int main ( int argc , string argv []) { // instead of void if ( argc == 2 ) { printf ( \"hello, %s \\n \" , argv [ 1 ]); } else { printf ( \"hello, world \\n \" ); } } argc and argv are two variables that our main function will now get automatically when our program is run from command line. argv is the short form for argument count , and argv , which is argument list (or argument list), is an array of strings. The first argument is argv[0] , which is the name of our program (the first word typed, like ./hello ). In this example, we check if we have two arguments, and print out the second one if so. E.g., if we run ./argv Lee , we'll get hello, Lee printed, since we typed in Lee as the second word in our command.","title":"7.1. argc and argv"},{"location":"notes/Harvard_CS50/0x02_Arrays/#72-return-value","text":"It turns out that our main function also returns an integer value . By default, our main function returns 0 to indicate nothing went wrong, but we can write a program to return a different value: 1 2 3 4 5 6 7 8 9 10 11 #include <stdio.h> #include <cs50.h> int main ( int argc , string argv []) { if ( argc != 2 ) { printf ( \"Missing command-line argument! \\n \" ); return 1 ; } printf ( \"Hello, %s \\n \" , argv [ 1 ]); return 0 ; } The return value of main in our program is called an exit code , usually used to indicate error codes. (We'll write return 0 explicitly at the end of our program here, even though we don't technically need to.) As we write more complex programs, error codes like this can help us determine what went wrong, even if it's not visible or meaningful to the user.","title":"7.2. Return value"},{"location":"notes/Harvard_CS50/0x02_Arrays/#8-applications","text":"Now that we know how to work with strings in our programs, as well code written by others in libraries, we can analyze paragraphs of text for their level of readability, based on factors like how long and complicated the words and sentences are.","title":"8. Applications"},{"location":"notes/Harvard_CS50/0x02_Arrays/#81-cryptography","text":"Cryptography is the art of scrambling, or hiding information. If we wanted to send a message to someone, we might want to encrypt , or somehow scramble that massage so that it would be hard for others to read. The original message, or input to out algorithm, in called plain-text , and the encrypted message, or output, is called cipher-text . And the algorithm that does the scrambling is called a cipher . A cipher generally requires another input in addition to the plain-text, which called Key , like a number, is some other input that is kept secret.","title":"8.1. Cryptography"},{"location":"notes/Harvard_CS50/0x02_Arrays/#82-example-of-cryptography","text":"If we wanted to send a message like I LOVE YOU , we can first convert it to ASCII: 73 76 79 86 69 89 79 85 . Then, we can encrypt it with a key of just 1 and a simple algorithm , where we just add the key to each value: 74 77 80 87 70 90 80 86 . Then, the cipher-text after we convert the values back to ASCII would be J MPWF ZPV . To decrypt this, someone would have to know the key is 1 , and to subtract it from each character,","title":"8.2. Example of Cryptography"},{"location":"notes/Harvard_CS50/0x03_Algorithms/","text":"1. Searching It turns out that, with arrays, computers cannot look at all of the elements at once. Computers can only do one thing at a time, such as look at one element of the array. Actually humans are also cannot do this, because there if only are several elements of the array, we could have a glance to see all of this, but how if we have billion or even trillion elements of array? And even there are only several elements, we still look at one element at a time, only we're too fast to sense that. Searching is how we solve problem of finding a particular value. A simple case might have an input of some array of values, and the output might simply be a bool value, whether or not a particular value is in the array. 1.1. Running time, Big O , Big \u03a9 Running time is how long an algorithms takes to run given some size of inout. And in week 0 we use the notation such as log 2 n , n and n/2 to describe running times, the more formal way to describe each of these running times is with Big O notation , which we can think of as on the order of . In Big O notation, we only care about the dominant factor , or largest term. Also there we have a similar notation called Big \u03a9 ,big Omega notation, which is the lower bound of number of steps for our algorithms, or the best case. Big O is the upper bound of number of steps, or the worst case. There are some common running times in Big O and Big \u03a9 : O (n^2^) O (n*log n) O (n) O (log n) O (1) An algorithm that takes a constant number of steps, regardless of how big the problem is. And: \u03a9(n^2^) \u03a9(n*log n) \u03a9(n) \u03a9(log n) \u03a9(1) 1.2. T function vs Big O When discussing an algorithm, the common usage of the symbol \ud835\udc47 is to represent its time complexity. \ud835\udc47 is a function. The input to this function is the input size, the output is the (worst-case) running time for an input of that size. Therefore, \ud835\udc47(\ud835\udc5b) is a number: the number returned by the function \ud835\udc47 when given the number \ud835\udc5b . This number is the running time of our algorithm on an input of size \ud835\udc5b . The \ud835\udc42 in \" \ud835\udc42(\ud835\udc5b) \" is not a function. This is Big O notation. In particular, the symbol \ud835\udc42(\ud835\udc5b) represents the class of all functions that grow (asymptotically) at most as quickly as the linear function \ud835\udc53(\ud835\udc5b)=\ud835\udc5b . Big O notation gives us a convenient way to talk about upper bounds. For example, we can say \"the time complexity of this algorithm is \ud835\udc42(\ud835\udc5b2) \" (formally: \" \ud835\udc47\u2208\ud835\udc42(\ud835\udc5b2) \") to say that the running time of the algorithm is at most quadratic in the input size. Sometimes, you can see both symbols being used in a single equation. For example, the time complexity of MergeSort is commonly described by the following recurrence: \" \ud835\udc47(\ud835\udc5b)=2\ud835\udc47(\ud835\udc5b/2)+\ud835\udc42(\ud835\udc5b) \". The meaning of the above statement: For any \ud835\udc5b , the time \ud835\udc47(\ud835\udc5b) needed to sort \ud835\udc5b elements can be computed by taking the time \ud835\udc47(\ud835\udc5b/2) needed to sort \ud835\udc5b/2 elements, multiplying that time by 2, and adding something extra. That something extra must be at most linear in \ud835\udc5b . 1.3. Linear search, binary search If we want to look for some number in an array of numbers, the simplest algorithm would be check each of these numbers from left to right, that is linear search . 1 2 3 4 For i from 0 to n-1: If the i'th of array is number: Return true Return false // Outside the for loop Input: a number we wanna find an array of numbers Output: a boolean value of whether our number is found Running time: O (n) \u03a9(1) If we know that the numbers in this array are sorted, then we can start in the middle, and find our value more efficiently, that is binary search . 1 2 3 4 5 6 7 8 If no numbers: Return false If the middle of array is number: Return true Else if middle number > number: Search left half Else if middle number < number: Search right half The input and output is same as the previous. Running time: O (log n) \u03a9(1) We perform steps at a frequency of one hertz (Hz), or cycle per second, and a processor's speed might be measured in gigahertz (GHz), or billion of operations per second. So the more efficient algorithms we choose, the more operations we could perform. 2. Structs If we wanted a type of variable more complex, such as a person in phone book, which contains their name and phone number, the basic types in C will not adequate. It turns out in C that we define our own data type, or data structure , with a struct in the following syntax: 1 2 3 4 5 6 7 typedef struct { string name ; string number ; } person ; // Using the dot operator \".\" to use the variable inside structs. person p ; p . name = \"Use dot\" ; We can see that one struct contains other data types inside it. With structs, we can be a little more confident that we won't have human errors in our program, which means we'll improve the robustness of our programs. 3. Sorting If out input is an unsorted list of numbers, there are many algorithms we could use to produce an output of a sorted list, where all the elements are in order. 3.1. Tradeoff With a sorted list, we can use binary search for efficiency, but it might take more time to write a sorting algorithm for that efficiency, so sometimes we'll encounter the tradeoff of time it takes a human to write a program compared to the time it takes a computer to run some algorithm. Other tradeoffs we'll see might be time and complexity , or time and memory usage . 3.2. Selection sort Selection sort is a simple sorting algorithm, and its pseudocode here: 1 2 3 For i from 0 to n-1 Find smallest item between i'th item and last item Swap smallest item with i'th item For this algorithm, we were looking at roughly all n elements to find the smallest currently, and making n passes to sort all the elements. Its running time is O (n^2^) . First we have to look at all n elements, then n-1, then n-2, and so on until there is only one element we need to look at. n + (n - 1) + (n - 2) + ... + 1 = n^2^/2 + n/2 = O (n^2^) And its lower bound of running time is \u03a9(n^2^) . The best case with a sorting algorithm is that the list of input has been sorted. Even though the list was sorted, Selection sort still need finding the smallest element n times, that still has the running time of n^2^ . 3.3. Bubble sort There also is a simple sorting algorithm called Bubble sort , where we swap pairs of numbers repeatedly. Here's its pseudocode: 1 2 3 4 5 6 Repeat n-1 times For i from 0 to n-2 // Since we're comparing the i'th and i+1'th If i'th and 1+i'th elements out of order Swap them If no swaps Quit And we can stop as soon as the list is sorted, since we can just remember whether we made any swaps. If not, the list must be stored already. This algorithm has O (n^2^) . We have n-1 comparisons in the loop, and at most n-1 loops, so we get n^2^-2n+1 steps total, where the largest factor is n^2^ . The lower bound for running time this algorithm would be \u03a9(n) . Once we look at all the elements is sorted we could quit. 4. Recursion Recursion is the ability for a function to call itself. 4.1. Merge sort We can take the idea of recursion to sorting, with another algorithm called Merge sort . The pseudocode might look like: 1 2 3 4 5 6 If only one number Return Else Sort left half of number Sort right half of number Merge sorted halves Notice the line 1 in pseudocode, this is recursion terminal condition . Once we haven't recursion terminal condition , the recursion will endless running. The magic of this algorithm is the line 6. It will return if there's only one element, then we could merge sorted halves, where the halves both are only one element, and of course is sorted, then we can back to the stage which invoked this stage, and then merge, and so forth. Each merging steps required n steps, there are log n stages containing merging, so total time is n*log n . So the upper bound for running time is O (n * log n) . And the lower bound is \u03a9(n * log n) , since we still have to sort each half first and then merge them together. 4.2. Tradeoff again Even though merge sort is likely to be faster than selection sort or bubble sort , we do need more memory to temporarily store our merged list at each stage. We face the tradeoff of incurring a higher cost, another array in memory, for the benefit of faster sorting. 5. Another notation Finally, there's another notation, \u03b8 \uff0cTheta, which we use describe running times of algorithms if the upper bound and lower bound is the same . For example, merge sort has \u03b8\uff08n logn) , and selection sort has \u03b8(n^2^) .","title":"Lec 03: Algorithms"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#1-searching","text":"It turns out that, with arrays, computers cannot look at all of the elements at once. Computers can only do one thing at a time, such as look at one element of the array. Actually humans are also cannot do this, because there if only are several elements of the array, we could have a glance to see all of this, but how if we have billion or even trillion elements of array? And even there are only several elements, we still look at one element at a time, only we're too fast to sense that. Searching is how we solve problem of finding a particular value. A simple case might have an input of some array of values, and the output might simply be a bool value, whether or not a particular value is in the array.","title":"1. Searching"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#11-running-time-big-o-big","text":"Running time is how long an algorithms takes to run given some size of inout. And in week 0 we use the notation such as log 2 n , n and n/2 to describe running times, the more formal way to describe each of these running times is with Big O notation , which we can think of as on the order of . In Big O notation, we only care about the dominant factor , or largest term. Also there we have a similar notation called Big \u03a9 ,big Omega notation, which is the lower bound of number of steps for our algorithms, or the best case. Big O is the upper bound of number of steps, or the worst case. There are some common running times in Big O and Big \u03a9 : O (n^2^) O (n*log n) O (n) O (log n) O (1) An algorithm that takes a constant number of steps, regardless of how big the problem is. And: \u03a9(n^2^) \u03a9(n*log n) \u03a9(n) \u03a9(log n) \u03a9(1)","title":"1.1. Running time, Big O, Big \u03a9"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#12-t-function-vs-big-o","text":"When discussing an algorithm, the common usage of the symbol \ud835\udc47 is to represent its time complexity. \ud835\udc47 is a function. The input to this function is the input size, the output is the (worst-case) running time for an input of that size. Therefore, \ud835\udc47(\ud835\udc5b) is a number: the number returned by the function \ud835\udc47 when given the number \ud835\udc5b . This number is the running time of our algorithm on an input of size \ud835\udc5b . The \ud835\udc42 in \" \ud835\udc42(\ud835\udc5b) \" is not a function. This is Big O notation. In particular, the symbol \ud835\udc42(\ud835\udc5b) represents the class of all functions that grow (asymptotically) at most as quickly as the linear function \ud835\udc53(\ud835\udc5b)=\ud835\udc5b . Big O notation gives us a convenient way to talk about upper bounds. For example, we can say \"the time complexity of this algorithm is \ud835\udc42(\ud835\udc5b2) \" (formally: \" \ud835\udc47\u2208\ud835\udc42(\ud835\udc5b2) \") to say that the running time of the algorithm is at most quadratic in the input size. Sometimes, you can see both symbols being used in a single equation. For example, the time complexity of MergeSort is commonly described by the following recurrence: \" \ud835\udc47(\ud835\udc5b)=2\ud835\udc47(\ud835\udc5b/2)+\ud835\udc42(\ud835\udc5b) \". The meaning of the above statement: For any \ud835\udc5b , the time \ud835\udc47(\ud835\udc5b) needed to sort \ud835\udc5b elements can be computed by taking the time \ud835\udc47(\ud835\udc5b/2) needed to sort \ud835\udc5b/2 elements, multiplying that time by 2, and adding something extra. That something extra must be at most linear in \ud835\udc5b .","title":"1.2. T function vs Big O"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#13-linear-search-binary-search","text":"If we want to look for some number in an array of numbers, the simplest algorithm would be check each of these numbers from left to right, that is linear search . 1 2 3 4 For i from 0 to n-1: If the i'th of array is number: Return true Return false // Outside the for loop Input: a number we wanna find an array of numbers Output: a boolean value of whether our number is found Running time: O (n) \u03a9(1) If we know that the numbers in this array are sorted, then we can start in the middle, and find our value more efficiently, that is binary search . 1 2 3 4 5 6 7 8 If no numbers: Return false If the middle of array is number: Return true Else if middle number > number: Search left half Else if middle number < number: Search right half The input and output is same as the previous. Running time: O (log n) \u03a9(1) We perform steps at a frequency of one hertz (Hz), or cycle per second, and a processor's speed might be measured in gigahertz (GHz), or billion of operations per second. So the more efficient algorithms we choose, the more operations we could perform.","title":"1.3. Linear search, binary search"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#2-structs","text":"If we wanted a type of variable more complex, such as a person in phone book, which contains their name and phone number, the basic types in C will not adequate. It turns out in C that we define our own data type, or data structure , with a struct in the following syntax: 1 2 3 4 5 6 7 typedef struct { string name ; string number ; } person ; // Using the dot operator \".\" to use the variable inside structs. person p ; p . name = \"Use dot\" ; We can see that one struct contains other data types inside it. With structs, we can be a little more confident that we won't have human errors in our program, which means we'll improve the robustness of our programs.","title":"2. Structs"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#3-sorting","text":"If out input is an unsorted list of numbers, there are many algorithms we could use to produce an output of a sorted list, where all the elements are in order.","title":"3. Sorting"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#31-tradeoff","text":"With a sorted list, we can use binary search for efficiency, but it might take more time to write a sorting algorithm for that efficiency, so sometimes we'll encounter the tradeoff of time it takes a human to write a program compared to the time it takes a computer to run some algorithm. Other tradeoffs we'll see might be time and complexity , or time and memory usage .","title":"3.1. Tradeoff"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#32-selection-sort","text":"Selection sort is a simple sorting algorithm, and its pseudocode here: 1 2 3 For i from 0 to n-1 Find smallest item between i'th item and last item Swap smallest item with i'th item For this algorithm, we were looking at roughly all n elements to find the smallest currently, and making n passes to sort all the elements. Its running time is O (n^2^) . First we have to look at all n elements, then n-1, then n-2, and so on until there is only one element we need to look at. n + (n - 1) + (n - 2) + ... + 1 = n^2^/2 + n/2 = O (n^2^) And its lower bound of running time is \u03a9(n^2^) . The best case with a sorting algorithm is that the list of input has been sorted. Even though the list was sorted, Selection sort still need finding the smallest element n times, that still has the running time of n^2^ .","title":"3.2. Selection sort"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#33-bubble-sort","text":"There also is a simple sorting algorithm called Bubble sort , where we swap pairs of numbers repeatedly. Here's its pseudocode: 1 2 3 4 5 6 Repeat n-1 times For i from 0 to n-2 // Since we're comparing the i'th and i+1'th If i'th and 1+i'th elements out of order Swap them If no swaps Quit And we can stop as soon as the list is sorted, since we can just remember whether we made any swaps. If not, the list must be stored already. This algorithm has O (n^2^) . We have n-1 comparisons in the loop, and at most n-1 loops, so we get n^2^-2n+1 steps total, where the largest factor is n^2^ . The lower bound for running time this algorithm would be \u03a9(n) . Once we look at all the elements is sorted we could quit.","title":"3.3. Bubble sort"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#4-recursion","text":"Recursion is the ability for a function to call itself.","title":"4. Recursion"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#41-merge-sort","text":"We can take the idea of recursion to sorting, with another algorithm called Merge sort . The pseudocode might look like: 1 2 3 4 5 6 If only one number Return Else Sort left half of number Sort right half of number Merge sorted halves Notice the line 1 in pseudocode, this is recursion terminal condition . Once we haven't recursion terminal condition , the recursion will endless running. The magic of this algorithm is the line 6. It will return if there's only one element, then we could merge sorted halves, where the halves both are only one element, and of course is sorted, then we can back to the stage which invoked this stage, and then merge, and so forth. Each merging steps required n steps, there are log n stages containing merging, so total time is n*log n . So the upper bound for running time is O (n * log n) . And the lower bound is \u03a9(n * log n) , since we still have to sort each half first and then merge them together.","title":"4.1. Merge sort"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#42-tradeoff-again","text":"Even though merge sort is likely to be faster than selection sort or bubble sort , we do need more memory to temporarily store our merged list at each stage. We face the tradeoff of incurring a higher cost, another array in memory, for the benefit of faster sorting.","title":"4.2. Tradeoff again"},{"location":"notes/Harvard_CS50/0x03_Algorithms/#5-another-notation","text":"Finally, there's another notation, \u03b8 \uff0cTheta, which we use describe running times of algorithms if the upper bound and lower bound is the same . For example, merge sort has \u03b8\uff08n logn) , and selection sort has \u03b8(n^2^) .","title":"5. Another notation"},{"location":"notes/Harvard_CS50/0x04_Memory/","text":"1. Hexadecimal 1.1. What is it In week2 ( Arrays ), we knew that each byte has an address , or identifier , so that we can refer to where our data is actually stored. It turns out that, by convention, the addresses for memory use the counting system hexadecimal , or base-16 , where there are 16 digit: 0~9 , and A~F represent 10~15 . 1 2 0x0F ( 0 * 16 ^ 1 ) + ( F * 16 ^ 0 ) == 15 ( base 10 ) In this example, 0x0F is 15 in decimal, where 0x is the prefix for hexadecimal. 1.2. Why use it One digit in hexadecimal is equal to four digits in binary, which binary is the counting system used by computers. (Each digit in hex with 16 different values, which map to four bits in bin, i.e. 2^4 = 16) Consequently, we could conveniently represent a byte in binary by using two digit in hex. 1.3. Application Due to each byte has an address , we'll use hexadecimal for each address or location for computer's memory. Also the RGB color system conventionally uses hexadecimal to describe the amount of color, i.e. 0xRRGGBB . E.g., 0x00 00 00 in hex represents 0 for each of red, green and blue, for a combined color of black. And 0xFF 00 00 would be 255 for red, which is the highest possible of amount of red. Similarly, 0xFF FF FF is the highest value of each color, combined to the brightest color white. 2. Addresses and Pointers 2.1. What are they We know that different variable may have a different type, e.g. int , double etc. Besides, the variables are stored somewhere in the computer's memory, just like the picture below. The address where stored this variable might look 0x12345678 , and the type of address value is called the pointer , we can save the address of this variable in a pointer variable p, which we can think of as a value that \"points\" to a location in memory. To declare a pointer, we can use * (also refer to dereference operator). 1 2 int n = 50 ; // declare a integer variable n int * p = & n ; // declare a pointer refer to an integer variable and assign &n to it This perhaps be confusing, *p is the dereferenced value of p , but we assign a value to it. 1 int array [ 50 ] = { element ...}; This is similar to the initialization of an array, where [50] is not get the 50th variable, but to declare the length of this array. Therefore, int *p is mean that the type of *p is an int, where *p is the dereferenced value which is an int, thus p is a pointer to the type int. When we initialize it, we assign value to p instead of *p . 2.2. & and dereference operator * In C, we can actually see the address with the & operator, which means get the address of this variable . We already know that it is the pointer which the type of address, to print out through printf we use %p for the format code for an address. 1 2 3 int n = 0 ; printf ( \"%p\" , & n ); // Out: 0x123.. Correspondingly, the * operator, aka dereference operator , is to go to the location that this pointer points to. 1 2 3 4 5 int n = 6 ; printf ( \"%i\" , *& n ); // Out: 6 // the dereferenced value of the address obtained from the variable is itself. // this is to say, & and * are mutually inverse. 2.3. the size of pointers It turns out that int have four bytes in computer's memory. Modern computer systems are \u201c64-bit\u201d, meaning that they use 64 bits to address memory, so a pointer will in reality be 8 bytes , twice as big as an integer of 4 bytes. 3. Application of the pointer 3.1. Strings In fact, the CS50 library defines a type that doesn't exist in C, string , as char * , with typedef char *string . It turns out that string s is just a pointer, the first address to s . Due to the string in C is ended by \\0 aka nul , we can easily find out where the end of this string. 3.2. Strings comparison and copying Once we know that what string or char * stored is the address of first character in each string, we'll understand that it's wrong to compare two strings through compare their pointers. Similarly, if we want to copy a string to another, we cannot just simply assign one string(pointer) to another one (pointer), cause this would make two pointers to the same location instead of copying. To actually make a copy of a string, we have to do a little more work, and copy each character in original string ( s ) to somewhere else in memory. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cs50.h> #include <ctype.h> #include <stdio.h> #include <stdlib.h> #include <string.h> int main ( void ) { char * s = get_string ( \"s: \" ); char * t = malloc ( strlen ( s ) + 1 ); // size of s + '\\0' (terminating null char) for ( int i = 0 , n = strlen ( s ); i < n + 1 ; i ++ ) { t [ i ] = s [ i ]; } t [ 0 ] = toupper ( t [ 0 ]); printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We create a new variable, t , of the type of char * , with char *t . Now we wanna point it to a new chunk of memory that's large enough to store the copy of the string. With malloc (memory allocate, in stdlib ), we allocate some number of bytes in memory (that aren't already used to store other memory), and we pass in the number of bytes we'd like to mark for use. 3.3. Error checking We can add some error-checking to our program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <cs50.h> #include <ctype.h> #include <stdio.h> #include <stdlib.h> #include <string.h> int main ( void ) { char * s = get_string ( \"s: \" ); char * t = malloc ( strlen ( s ) + 1 ); if ( t == NULL ) { return 1 ; } for ( int i = 0 , n = strlen ( s ); i < n + 1 ; i ++ ) { t [ i ] = s [ i ]; } if ( strlen ( t ) > 0 ) { t [ 0 ] = toupper ( t [ 0 ]); } printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); free ( t ); } If our computer is out of memory , malloc will return NULL , the null ptr, or a special value that indicate there isn't an address to point to. So we should check for that case, and exit if t is NULL . We could also check that t has a length, before trying to do something in that memory. Finally, we should free the memory we allocated earlier, which marks it as usable again by some other program. We call the free function and pass in the pointer t , since we're done with that chunk of memory, we no longer need that chunk of memory. We can actually also use the strcpy function, from the C\u2019s string library, with strcpy(t, s); instead of our loop, to copy the string s into t . 3.4. scanf \u200b We can get a string using scanf . 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { char * s ; printf ( \"s: \" ); scanf ( \"%s\" , s ); printf ( \"s: %s \\n \" , s ); } But we haven't actually allocate any memory for s , so we need to call malloc to allocate some memory to s , or char s[N] . Now, if the user types in a string of length 3 or less, our program will work safely. But if the user types in a longer string, scanf might be trying to write past the end of our array into unknown memory, causing our program to crash. 3.5. Pointer arithmetic Pointer arithmetic is mathematical operations on addresses with pointers. 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { char * s = \"HI!\" ; printf ( \"%c \\n \" , * s ); printf ( \"%c \\n \" , * ( s + 1 )); printf ( \"%c \\n \" , * ( s + 2 )); } *s goes to the address stored in s , and *(s+1) goes to the location in memory that the next of the array instead of the next bit , this is to say, add the bits of the type have to this address. We can even try to go to the address in memory that we shouldn't, like with *(s + 1000000000) , and when we run our program, we\u2019ll get a segmentation fault , or crash as a result of our program touching memory in a segment it shouldn\u2019t have. 4. Memory leaks and Garbage values 4.1. Memory leaks and Valgrind valgrind is a command-line tool that we can use to run our program and see if it has any memory leaks , or memory we've allocated without freeing, which might eventually cause out computer to run out of memory. 4.2. Garbage values 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main ( void ) { int * x ; int * y ; x = malloc ( sizeof ( int )); * x = 42 ; * y = 13 ; y = x ; * y = 13 ; } With *y = 13 , we trying to put the value 13 at the address y points to. But since we never assigned y a value, it has a garbage value , or whatever unknown value that was in memory, from whatever program was running in our computer before. So when we're trying to go to the garbage value in y as an address, we're going to some unknown address, which is likely to cause a segmentation fault, or segfault. 5. Memory layout 5.1. What is memory layout Within our computer's memory, the different types of data that need to be stored for our program are organized into different sections. The machine code section is our complied program's binary code. When we run our program, that code is loaded into the \"top\" of memory. Just below, or in the next part of memory, are global variables we declared in our program. The heap section is an empty area from where malloc can get free memory for our program to use. As we call malloc , we starting allocate memory from the top down. The stack section is used by functions in our program as they called, and grows upward. E.g. the picture below. 5.2. heap/stack/buffer overflow If we called malloc for too much memory then the heap section run out of space, we'll have a heap overflow , since we end up going past our heap. Or, if we call too much functions without returning from them, we'll have a stack overflow , where our stack has too much memory allocated as well. A buffer overflow occurs when we go past the end of a buffer, some chunk of memory we\u2019ve allocated like an array, and access memory we shouldn\u2019t be. 6. File I/O 6.1. fopen, fprintf and FILE type With the ability to use pointers, we can also open files , like a digital phone book. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { FILE * file = fopen ( \"phonebook.csv\" , \"a\" ); if ( file == NULL ) { return 1 ; } char * name = get_string ( \"Name: \" ); char * number = get_string ( \"Number: \" ); fprintf ( file , \"%s,%s \\n \" , name , number ); fclose ( file ); } fopen is a new function that we can use to open a file, which will return a pointer to a new type, FILE , that we can read from and write to. The first argument of fopen in this example is the name of file , and the second is the mode we want to open file in, i.e. r for read, w for write, a for append or adding to. Similarly as above, we have to add a check to exit if we couldn't open the file for some reason. After we get some strings, we could use fprintf to print to a file. Finally, we close the file with fclose . Now we can create our own CSV files, a file of comma-separated values (like a mini-spreadsheet), programmatically. 6.2. Graphic We can read in binary and map them to pixels and colors, to display images and videos. With a finite number of bits in an image file, though, we can only zoom in so far before we start seeing individual pixels. With artificial intelligence and machine learning, however, we can use algorithms that can generate additional details that weren\u2019t there before, by guessing based on other data. Let\u2019s look at a program that opens a file and tells us if it\u2019s a JPEG file, an image file in a particular format: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <stdint.h> #include <stdio.h> typedef uint8_t BYTE ; int main ( int argc , char * argv []) { // Check usage if ( argc != 2 ) { return 1 ; } // Open file FILE * file = fopen ( argv [ 1 ], \"r\" ); if ( ! file ) { return 1 ; } // Read first three bytes BYTE bytes [ 3 ]; fread ( bytes , sizeof ( BYTE ), 3 , file ); // Check first three bytes if ( bytes [ 0 ] == 0xff && bytes [ 1 ] == 0xd8 && bytes [ 2 ] == 0xff ) { printf ( \"Maybe \\n \" ); } else { printf ( \"No \\n \" ); } // Close file fclose ( file ); } First, we define a BYTE as 8 bits, so we can refer to a byte as a type more easily in C. Then, we try to open a file (checking that we indeed get a non-NULL file back), and read the first three bytes from the file with fread , into a buffer called bytes . We can compare the first three bytes (in hexadecimal) to the three bytes required to begin a JPEG file. If they\u2019re the same, then our file is likely to be a JPEG file (though, other types of files may still begin with those bytes). But if they\u2019re not the same, we know it\u2019s definitely not a JPEG file. We can even copy files ourselves, one byte at a time now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <stdint.h> #include <stdio.h> #include <stdlib.h> typedef uint8_t BYTE ; int main ( int argc , char * argv []) { // Ensure proper usage if ( argc != 3 ) { fprintf ( stderr , \"Usage: copy SOURCE DESTINATION \\n \" ); return 1 ; } // open input file FILE * source = fopen ( argv [ 1 ], \"r\" ); if ( source == NULL ) { printf ( \"Could not open %s. \\n \" , argv [ 1 ]); return 1 ; } // Open output file FILE * destination = fopen ( argv [ 2 ], \"w\" ); if ( destination == NULL ) { fclose ( source ); printf ( \"Could not create %s. \\n \" , argv [ 2 ]); return 1 ; } // Copy source to destination, one BYTE at a time BYTE buffer ; while ( fread ( & buffer , sizeof ( BYTE ), 1 , source )) { fwrite ( & buffer , sizeof ( BYTE ), 1 , destination ); } // Close files fclose ( source ); fclose ( destination ); return 0 ; } We use argv to get arguments, using them as filenames to open files to read from and one to write to. Then, we read one byte from the source file into a buffer, and write that byte to the destination file. We can use a while loop to call fread , which will stop once there are no more bytes to read.","title":"Lec 04: Memory"},{"location":"notes/Harvard_CS50/0x04_Memory/#1-hexadecimal","text":"","title":"1. Hexadecimal"},{"location":"notes/Harvard_CS50/0x04_Memory/#11-what-is-it","text":"In week2 ( Arrays ), we knew that each byte has an address , or identifier , so that we can refer to where our data is actually stored. It turns out that, by convention, the addresses for memory use the counting system hexadecimal , or base-16 , where there are 16 digit: 0~9 , and A~F represent 10~15 . 1 2 0x0F ( 0 * 16 ^ 1 ) + ( F * 16 ^ 0 ) == 15 ( base 10 ) In this example, 0x0F is 15 in decimal, where 0x is the prefix for hexadecimal.","title":"1.1. What is it"},{"location":"notes/Harvard_CS50/0x04_Memory/#12-why-use-it","text":"One digit in hexadecimal is equal to four digits in binary, which binary is the counting system used by computers. (Each digit in hex with 16 different values, which map to four bits in bin, i.e. 2^4 = 16) Consequently, we could conveniently represent a byte in binary by using two digit in hex.","title":"1.2. Why use it"},{"location":"notes/Harvard_CS50/0x04_Memory/#13-application","text":"Due to each byte has an address , we'll use hexadecimal for each address or location for computer's memory. Also the RGB color system conventionally uses hexadecimal to describe the amount of color, i.e. 0xRRGGBB . E.g., 0x00 00 00 in hex represents 0 for each of red, green and blue, for a combined color of black. And 0xFF 00 00 would be 255 for red, which is the highest possible of amount of red. Similarly, 0xFF FF FF is the highest value of each color, combined to the brightest color white.","title":"1.3. Application"},{"location":"notes/Harvard_CS50/0x04_Memory/#2-addresses-and-pointers","text":"","title":"2. Addresses and Pointers"},{"location":"notes/Harvard_CS50/0x04_Memory/#21-what-are-they","text":"We know that different variable may have a different type, e.g. int , double etc. Besides, the variables are stored somewhere in the computer's memory, just like the picture below. The address where stored this variable might look 0x12345678 , and the type of address value is called the pointer , we can save the address of this variable in a pointer variable p, which we can think of as a value that \"points\" to a location in memory. To declare a pointer, we can use * (also refer to dereference operator). 1 2 int n = 50 ; // declare a integer variable n int * p = & n ; // declare a pointer refer to an integer variable and assign &n to it This perhaps be confusing, *p is the dereferenced value of p , but we assign a value to it. 1 int array [ 50 ] = { element ...}; This is similar to the initialization of an array, where [50] is not get the 50th variable, but to declare the length of this array. Therefore, int *p is mean that the type of *p is an int, where *p is the dereferenced value which is an int, thus p is a pointer to the type int. When we initialize it, we assign value to p instead of *p .","title":"2.1. What are they"},{"location":"notes/Harvard_CS50/0x04_Memory/#22-and-dereference-operator","text":"In C, we can actually see the address with the & operator, which means get the address of this variable . We already know that it is the pointer which the type of address, to print out through printf we use %p for the format code for an address. 1 2 3 int n = 0 ; printf ( \"%p\" , & n ); // Out: 0x123.. Correspondingly, the * operator, aka dereference operator , is to go to the location that this pointer points to. 1 2 3 4 5 int n = 6 ; printf ( \"%i\" , *& n ); // Out: 6 // the dereferenced value of the address obtained from the variable is itself. // this is to say, & and * are mutually inverse.","title":"2.2. &amp; and dereference operator *"},{"location":"notes/Harvard_CS50/0x04_Memory/#23-the-size-of-pointers","text":"It turns out that int have four bytes in computer's memory. Modern computer systems are \u201c64-bit\u201d, meaning that they use 64 bits to address memory, so a pointer will in reality be 8 bytes , twice as big as an integer of 4 bytes.","title":"2.3. the size of pointers"},{"location":"notes/Harvard_CS50/0x04_Memory/#3-application-of-the-pointer","text":"","title":"3. Application of the pointer"},{"location":"notes/Harvard_CS50/0x04_Memory/#31-strings","text":"In fact, the CS50 library defines a type that doesn't exist in C, string , as char * , with typedef char *string . It turns out that string s is just a pointer, the first address to s . Due to the string in C is ended by \\0 aka nul , we can easily find out where the end of this string.","title":"3.1. Strings"},{"location":"notes/Harvard_CS50/0x04_Memory/#32-strings-comparison-and-copying","text":"Once we know that what string or char * stored is the address of first character in each string, we'll understand that it's wrong to compare two strings through compare their pointers. Similarly, if we want to copy a string to another, we cannot just simply assign one string(pointer) to another one (pointer), cause this would make two pointers to the same location instead of copying. To actually make a copy of a string, we have to do a little more work, and copy each character in original string ( s ) to somewhere else in memory. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cs50.h> #include <ctype.h> #include <stdio.h> #include <stdlib.h> #include <string.h> int main ( void ) { char * s = get_string ( \"s: \" ); char * t = malloc ( strlen ( s ) + 1 ); // size of s + '\\0' (terminating null char) for ( int i = 0 , n = strlen ( s ); i < n + 1 ; i ++ ) { t [ i ] = s [ i ]; } t [ 0 ] = toupper ( t [ 0 ]); printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We create a new variable, t , of the type of char * , with char *t . Now we wanna point it to a new chunk of memory that's large enough to store the copy of the string. With malloc (memory allocate, in stdlib ), we allocate some number of bytes in memory (that aren't already used to store other memory), and we pass in the number of bytes we'd like to mark for use.","title":"3.2. Strings comparison and copying"},{"location":"notes/Harvard_CS50/0x04_Memory/#33-error-checking","text":"We can add some error-checking to our program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <cs50.h> #include <ctype.h> #include <stdio.h> #include <stdlib.h> #include <string.h> int main ( void ) { char * s = get_string ( \"s: \" ); char * t = malloc ( strlen ( s ) + 1 ); if ( t == NULL ) { return 1 ; } for ( int i = 0 , n = strlen ( s ); i < n + 1 ; i ++ ) { t [ i ] = s [ i ]; } if ( strlen ( t ) > 0 ) { t [ 0 ] = toupper ( t [ 0 ]); } printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); free ( t ); } If our computer is out of memory , malloc will return NULL , the null ptr, or a special value that indicate there isn't an address to point to. So we should check for that case, and exit if t is NULL . We could also check that t has a length, before trying to do something in that memory. Finally, we should free the memory we allocated earlier, which marks it as usable again by some other program. We call the free function and pass in the pointer t , since we're done with that chunk of memory, we no longer need that chunk of memory. We can actually also use the strcpy function, from the C\u2019s string library, with strcpy(t, s); instead of our loop, to copy the string s into t .","title":"3.3. Error checking"},{"location":"notes/Harvard_CS50/0x04_Memory/#34-scanf","text":"\u200b We can get a string using scanf . 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { char * s ; printf ( \"s: \" ); scanf ( \"%s\" , s ); printf ( \"s: %s \\n \" , s ); } But we haven't actually allocate any memory for s , so we need to call malloc to allocate some memory to s , or char s[N] . Now, if the user types in a string of length 3 or less, our program will work safely. But if the user types in a longer string, scanf might be trying to write past the end of our array into unknown memory, causing our program to crash.","title":"3.4. scanf"},{"location":"notes/Harvard_CS50/0x04_Memory/#35-pointer-arithmetic","text":"Pointer arithmetic is mathematical operations on addresses with pointers. 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { char * s = \"HI!\" ; printf ( \"%c \\n \" , * s ); printf ( \"%c \\n \" , * ( s + 1 )); printf ( \"%c \\n \" , * ( s + 2 )); } *s goes to the address stored in s , and *(s+1) goes to the location in memory that the next of the array instead of the next bit , this is to say, add the bits of the type have to this address. We can even try to go to the address in memory that we shouldn't, like with *(s + 1000000000) , and when we run our program, we\u2019ll get a segmentation fault , or crash as a result of our program touching memory in a segment it shouldn\u2019t have.","title":"3.5. Pointer arithmetic"},{"location":"notes/Harvard_CS50/0x04_Memory/#4-memory-leaks-and-garbage-values","text":"","title":"4. Memory leaks and Garbage values"},{"location":"notes/Harvard_CS50/0x04_Memory/#41-memory-leaks-and-valgrind","text":"valgrind is a command-line tool that we can use to run our program and see if it has any memory leaks , or memory we've allocated without freeing, which might eventually cause out computer to run out of memory.","title":"4.1. Memory leaks and Valgrind"},{"location":"notes/Harvard_CS50/0x04_Memory/#42-garbage-values","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main ( void ) { int * x ; int * y ; x = malloc ( sizeof ( int )); * x = 42 ; * y = 13 ; y = x ; * y = 13 ; } With *y = 13 , we trying to put the value 13 at the address y points to. But since we never assigned y a value, it has a garbage value , or whatever unknown value that was in memory, from whatever program was running in our computer before. So when we're trying to go to the garbage value in y as an address, we're going to some unknown address, which is likely to cause a segmentation fault, or segfault.","title":"4.2. Garbage values"},{"location":"notes/Harvard_CS50/0x04_Memory/#5-memory-layout","text":"","title":"5. Memory layout"},{"location":"notes/Harvard_CS50/0x04_Memory/#51-what-is-memory-layout","text":"Within our computer's memory, the different types of data that need to be stored for our program are organized into different sections. The machine code section is our complied program's binary code. When we run our program, that code is loaded into the \"top\" of memory. Just below, or in the next part of memory, are global variables we declared in our program. The heap section is an empty area from where malloc can get free memory for our program to use. As we call malloc , we starting allocate memory from the top down. The stack section is used by functions in our program as they called, and grows upward. E.g. the picture below.","title":"5.1. What is memory layout"},{"location":"notes/Harvard_CS50/0x04_Memory/#52-heapstackbuffer-overflow","text":"If we called malloc for too much memory then the heap section run out of space, we'll have a heap overflow , since we end up going past our heap. Or, if we call too much functions without returning from them, we'll have a stack overflow , where our stack has too much memory allocated as well. A buffer overflow occurs when we go past the end of a buffer, some chunk of memory we\u2019ve allocated like an array, and access memory we shouldn\u2019t be.","title":"5.2. heap/stack/buffer overflow"},{"location":"notes/Harvard_CS50/0x04_Memory/#6-file-io","text":"","title":"6. File I/O"},{"location":"notes/Harvard_CS50/0x04_Memory/#61-fopen-fprintf-and-file-type","text":"With the ability to use pointers, we can also open files , like a digital phone book. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { FILE * file = fopen ( \"phonebook.csv\" , \"a\" ); if ( file == NULL ) { return 1 ; } char * name = get_string ( \"Name: \" ); char * number = get_string ( \"Number: \" ); fprintf ( file , \"%s,%s \\n \" , name , number ); fclose ( file ); } fopen is a new function that we can use to open a file, which will return a pointer to a new type, FILE , that we can read from and write to. The first argument of fopen in this example is the name of file , and the second is the mode we want to open file in, i.e. r for read, w for write, a for append or adding to. Similarly as above, we have to add a check to exit if we couldn't open the file for some reason. After we get some strings, we could use fprintf to print to a file. Finally, we close the file with fclose . Now we can create our own CSV files, a file of comma-separated values (like a mini-spreadsheet), programmatically.","title":"6.1. fopen, fprintf and FILE type"},{"location":"notes/Harvard_CS50/0x04_Memory/#62-graphic","text":"We can read in binary and map them to pixels and colors, to display images and videos. With a finite number of bits in an image file, though, we can only zoom in so far before we start seeing individual pixels. With artificial intelligence and machine learning, however, we can use algorithms that can generate additional details that weren\u2019t there before, by guessing based on other data. Let\u2019s look at a program that opens a file and tells us if it\u2019s a JPEG file, an image file in a particular format: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <stdint.h> #include <stdio.h> typedef uint8_t BYTE ; int main ( int argc , char * argv []) { // Check usage if ( argc != 2 ) { return 1 ; } // Open file FILE * file = fopen ( argv [ 1 ], \"r\" ); if ( ! file ) { return 1 ; } // Read first three bytes BYTE bytes [ 3 ]; fread ( bytes , sizeof ( BYTE ), 3 , file ); // Check first three bytes if ( bytes [ 0 ] == 0xff && bytes [ 1 ] == 0xd8 && bytes [ 2 ] == 0xff ) { printf ( \"Maybe \\n \" ); } else { printf ( \"No \\n \" ); } // Close file fclose ( file ); } First, we define a BYTE as 8 bits, so we can refer to a byte as a type more easily in C. Then, we try to open a file (checking that we indeed get a non-NULL file back), and read the first three bytes from the file with fread , into a buffer called bytes . We can compare the first three bytes (in hexadecimal) to the three bytes required to begin a JPEG file. If they\u2019re the same, then our file is likely to be a JPEG file (though, other types of files may still begin with those bytes). But if they\u2019re not the same, we know it\u2019s definitely not a JPEG file. We can even copy files ourselves, one byte at a time now: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <stdint.h> #include <stdio.h> #include <stdlib.h> typedef uint8_t BYTE ; int main ( int argc , char * argv []) { // Ensure proper usage if ( argc != 3 ) { fprintf ( stderr , \"Usage: copy SOURCE DESTINATION \\n \" ); return 1 ; } // open input file FILE * source = fopen ( argv [ 1 ], \"r\" ); if ( source == NULL ) { printf ( \"Could not open %s. \\n \" , argv [ 1 ]); return 1 ; } // Open output file FILE * destination = fopen ( argv [ 2 ], \"w\" ); if ( destination == NULL ) { fclose ( source ); printf ( \"Could not create %s. \\n \" , argv [ 2 ]); return 1 ; } // Copy source to destination, one BYTE at a time BYTE buffer ; while ( fread ( & buffer , sizeof ( BYTE ), 1 , source )) { fwrite ( & buffer , sizeof ( BYTE ), 1 , destination ); } // Close files fclose ( source ); fclose ( destination ); return 0 ; } We use argv to get arguments, using them as filenames to open files to read from and one to write to. Then, we read one byte from the source file into a buffer, and write that byte to the destination file. We can use a while loop to call fread , which will stop once there are no more bytes to read.","title":"6.2. Graphic"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/","text":"1. Resizing arrays 1.1. How to resizing arrays We already know that array is a contiguous spaces in computer's memory in which we could store values, and we use malloc to acquire a chunk of memory from system for the array. But once we get memory through malloc , the size of arrays is fixed . If there is some input but our array haven't enough memory for those extra inputs, we have to resize our array. One solution is to allocate more memory where there's enough space, and then move our original array there. But it will need more time to copy our array to new space, which becomes an operation with running time of O (n) . And the lower bound of inserting an element into an array would be O (1) , since we might already have enough space in the array for storing it. 1.2. Implementing resizing arrays Let's see how we might implement resizing an array: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <stdio.h> #include <stdlib.h> const int N = some_integer ; int main ( void ) { // suppose we already have an array with N integer values int * list = malloc ( N * sizeof ( int )); // Now we want to store another value, that is to resize this array // Fisrt allocate more memory to store extra value int * tmp = malloc (( N + 1 ) * sizeof ( int )); if ( tmp == NULL ) { // free the memory that we allocated before exit the program free ( list ); return 1 ; } // copy original list to tmp for ( int i = 0 ; i < N ; i ++ ) { tmp [ i ] = list [ i ]; } // Now we can store new integer tmp [ N ] = new_number ; // Free the original list which won't be used anymore free ( list ); // Point to new list list = tmp ; // Free all the memory we allocated before we exit the program free ( list ); return 0 ; } We can see it's troublesome if we handling this process ourselves. Therefore, C provides a function realloc , to reallocate some memory that we allocate earlier from heap areas using malloc . 1 int * tmp = realloc ( list , ( N + 1 ) * sizeof ( int )); And realloc copies our old array, list , for us into a bigger chunk of memory of the size we pass in. If there happens to be spaces after out existing chunk of memory, we'll get the same address back, but with the memory after it allocated to our variable as well. 2. Data structures Data structures are more complex ways to organize data in memory, allowing us to store information in different layouts . To build a data structure, we'll need some tools: struct to create custom data types . to access properties in a structure * to go to an address in memory pointed by a pointer -> to access properties in a struct pointed by a pointer 3. Linked list 3.1. What is linked list With a linked list , we can store a list of values that can easily be grown by storing values in different parts of memory. E.g. we have the values 1 , 2 and 3 , each at some address in memory like 0x123 , 0x234 , and 0x345 , which are not contiguous addresses. So it's different than the array, that is we can use whatever locations in memory that are free. 3.2. How to implement Due to these address are not contiguous in memory, we cannot track them by indexing addresses. So we need link our list together by allocating, for each element, enough memory for both the value we want to store, and the address of the next address . We'll call it a node , which a component of our data structure that stores both a value and a pointer. As we mentioned before, we'll implement out nodes with a structure . And notice that, the last node of linked list, we have the null pointer since there's no next element. When we need to insert another node, we just change the single null ptr to point our new node. 3.3. Trade off We have the trade off of needing to allocate twice as much memory for each element, in order to spend less time adding values. And we no longer can use binary search, which depends on the index of address yet our nodes might be anywhere in memory. 3.4. Implementing nodes Before we implement linked lists, we have to implement the component of linked lists, nodes . In code, we might want to create our own struct called node , and we need to store both our value, an int called number , and a pointer to the next node , called next . 1 2 3 4 5 typedef struct node { int number ; struct node * next ; } node ; Notice that we start with typedef struct node so that we can refer to a node inside our struct. 3.5. Implementing linked lists 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include <stdio.h> #include <stdlib.h> // Represent a node typedef struct node { int number ; struct node * next ; } node ; int main ( void ) { // List of size 0. We initialize the value to NULL explicitly, so there's no // garbage value for our list variable node * list = NULL : // Allocate memory for a node, n node * n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } // Set the value and pointer to our node n -> value = N ; n -> next = NULL : // Add node n by pointing list to it, since we only have one node so far list = n ; // Allocate memory for another node, and we can reuse our variable n to point // to it, since list points to the first node alraedy n = malloc ( sizeof ( node )); if ( n == NULL ) { free ( list ); return 1 ; } // Set the values in our new node n -> number = N ; n -> next = NULL ; // Update the pointer in our first node to point to the second node list -> next = n ; // Allocate memory for the third node n = malloc ( sizeof ( node )); if ( n == NULL ) { // free both of our other nodes free ( list -> next ); free ( list ); return 1 ; } // Follow the next pointer of the list to the second node, and update // the next pointer there to point to n list -> next -> next = n ; // Print list using a loop, by using a temporary variable, tmp, to point // to list, the first node. Then, every time we go over the loop, we use // tmp = tmp->next to update our temporary pointer to the next node. // We might keep going as tmp points somewhere, stopping when we get the last // node and tmp->next == null, namely there's no more nodes after this node. for ( node * tmp = list ; tmp != NULL ; tmp = tmp -> next ) { printf ( \"%i \\n \" , tmp -> number ); } // Free list, by using a while loop and a temporary variable to point to // the next node before freeing the current one. while ( list != NULL ) { // Point to the next node first node * tmp = list -> next ; // Then, free the first node free ( list ); // Now we can set the list point to the next node list = tmp ; } } If we want to insert a node to the front of our linked list, we should need to carefully update our node to point to the one following it, before updating the list variable. Otherwise, we'll lose the rest of our list. 1 2 3 4 // Here, we're inserting a node into the front of the list, so we want its next // pointer to point to the orginal list. Then we can change the list to point to n. n -> next = list ; list = n ; That is, at first we'll have a node with value 1 pointing to the start of our list, a node with value 2 . Now we can change our list variable to point to the node with value 1 , and not lost the rest of our list. Similarly, to insert a node into the middle of our list, we can change the next pointer of new node first to point to the rest of the list, then update the previous node to the new node. A linked list demonstrates how we can build flexible data structure in memory, though we're only visualizing it in one dimension . 4. Tree 4.1. What is Tree With a sorted array, we can use binary search to find an element, starting at the middle (the yellow one), then the middle of either half (red), and finally left or right (green) as needed. With an array, we can randomly access elements in O(1) time, since we can use arithmetic to go to an element at any index. A tree is another data structure where each node points two other nodes, one to the left (with a smaller value) and one to the right (with a larger value). Notice that we now visualize this data structure in two dimensions (even though the nodes in memory can be at any location). And we can implement this with a more complex version of a node in a linked list, where each node has not one but two pointers to other nodes. All the value to the left of a node are smaller , and all the value to the right are greater, which allows this to be used as a binary search tree . And the data structure is itself defined recursively, so we can use recursive functions to work with it. Each node has at most two children, i.e. nodes it's pointing to. 4.2. Implementing Binary Search Tree Like a linked list, we'll want to keep a pointer to just the beginning of the list, but in this case we want to point to the root , or top center node of the tree ( 4 in this case). We can define a node with not one but two pointers: 1 2 3 4 5 6 typedef struct node { int number ; struct node * left ; struct node * right ; } node ; And write a function to recursively search a tree: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // tree is pointer to a node that is the root of the tree we're searching in. // number is a value we're trying to find in the tree. bool search ( node * tree , int value ) { // Fisrt, make sure that the tree isn't NULL, if we're reached a node on the // bottom, or if our tree is entirely empty. if ( tree == NULL ) { return false ; } // If we're looking for a number that's less than the tree's number, search the // left side, using the node on the left as the new tree. else if ( number < tree -> number ) { return search ( number , tree -> left ); } // Otherwise, search the right side, using the node on the right as the new tree. else if ( number > tree -> number ) { return search ( number , tree -> right ); } // Finally, we've found the number we've looking for, so we can return true. // We can simplify this to just \"else\", since there's no other case possible else if ( number == tree -> number ) { return true ; } } 4.3. Trade off With a binary search tree, we've incurred the cost of even more memory, since each node now needs space for a value and two pointers. Inserting a new value would take O(log n) time, since we need to find the nodes that it should go between. If we add enough nodes, though, our search tree might start to look like a linked list: That is, we started our tree with a node with value 1 , then added the node with value 2 , and finally added the node with value 3 . Even though this tree follows the constraints of a binary search tree, it's not as efficient as it could be. We can make this tree balanced, or optimal, by making the node with value 2 the new root node. More advanced courses will cover data structures and algorithms that help us keep trees balanced as nodes are added. 5. More data structures 5.1. Hash table A data structure with almost a constant time, O(1) search is a Hash table , which is essentially an array of linked lists . Each linked list in the array has elements of a certain category. E.g., we might have lots of names, and we might sort then into an array with 26 positions, one for each letter of the alphabet. Since we have random access with arrays, we can set elements and index into a location, or bucket, in the array quickly. A location might have multiple matching values, but we can add a value to another value since they're nodes in a linked list, as we see with Hermione, Harry, and Hagird. We don't need to grow the size of our array or move any of our other values. This is called hash table because we use a hash function , which takes some input and deterministically maps it to the location it should go in. In our example, the hash function just returns an index corresponding to the first letter of the name, such as 0 for \"Albus\" and 25 for \"Zacharias\". But in the worst case, all the names might start with the same letter, so we might end up with the equivalent of a single linked list again. We might look at the first two letters, and allocate enough buckets for 26*26 possible hashed values, or even the first three letters, requiring 26*26*26 buckets. Now, we're using more space in memory, since more of those buckets will be empty, but we're more likely to only need one step to look for a value, reducing our running time for search. To sort some standard playing cards, too, we might first start with putting them in piles by suit, of spades, diamonds, hearts, and clubs. Then, we can sort each pile a little more quickly. It turns out that the worst case running time for a hash table is O( n ), since, as n gets very large, each bucket will have on the order of n values, even if we have hundreds or thousands of buckets. In practice, though, our running time will be faster since we\u2019re dividing our values into multiple buckets. 5.2. Trie We can use another data structure called a trie , (pronounced like \"try\", and is short for \"retrieval\"). A trie is a tree with arrays as nodes. In this case, each array will have each letter, A-Z, stored. For each word, the first letter will point to an array, where the next valid letter will point to another array, and so on, until we reach a boolean value indicating the end of a valid word, marked in green above. If our word isn\u2019t in the trie, then one of the arrays won\u2019t have a pointer or terminating character for our word. Now, let's consider the trade off for this data structure, even if our data structure has lots of words, the maximum lookup time will be just the length of the word we\u2019re looking for. This might be a fixed maximum, so we can have O (1) for searching and insertion. The cost for this, though, is that we need lots of memory to store pointers and boolean values as indicators of valid words, even though lots of them won\u2019t be used. 5.3. Abstract data structures There are even higher-level constructs, abstract data structures , where we use our building blocks of arrays, linked list, hash tables, and tries to implement a solution to some problem. 5.4. queue For example, one abstract data structure is a queue , like a line of people waiting, where the first value we put in are the first values that are removed, or first-in-first-out (FIFO). To add a value we enqueue it, and to remove a value we dequeue it. This data structure is abstract because it\u2019s an idea that we can implement in different ways: with an array that we resize as we add and remove items, or with a linked list where we append values to the end. 5.5. Stack An \u201copposite\u201d data structure would be a stack , where items most recently added are removed first: last-in-first-out (LIFO). At a clothing store, we might take, or pop , the top sweater from a stack, and new sweaters would be added, or pushed , to the top as well. 5.6. Dictionary Another example of an abstract data structure is a dictionary , where we can map keys to values, such as words to their definitions. We can implement one with a hash table or an array, taking into account the tradeoff between time and space.","title":"Lec 05: Data Structures"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#1-resizing-arrays","text":"","title":"1. Resizing arrays"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#11-how-to-resizing-arrays","text":"We already know that array is a contiguous spaces in computer's memory in which we could store values, and we use malloc to acquire a chunk of memory from system for the array. But once we get memory through malloc , the size of arrays is fixed . If there is some input but our array haven't enough memory for those extra inputs, we have to resize our array. One solution is to allocate more memory where there's enough space, and then move our original array there. But it will need more time to copy our array to new space, which becomes an operation with running time of O (n) . And the lower bound of inserting an element into an array would be O (1) , since we might already have enough space in the array for storing it.","title":"1.1. How to resizing arrays"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#12-implementing-resizing-arrays","text":"Let's see how we might implement resizing an array: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <stdio.h> #include <stdlib.h> const int N = some_integer ; int main ( void ) { // suppose we already have an array with N integer values int * list = malloc ( N * sizeof ( int )); // Now we want to store another value, that is to resize this array // Fisrt allocate more memory to store extra value int * tmp = malloc (( N + 1 ) * sizeof ( int )); if ( tmp == NULL ) { // free the memory that we allocated before exit the program free ( list ); return 1 ; } // copy original list to tmp for ( int i = 0 ; i < N ; i ++ ) { tmp [ i ] = list [ i ]; } // Now we can store new integer tmp [ N ] = new_number ; // Free the original list which won't be used anymore free ( list ); // Point to new list list = tmp ; // Free all the memory we allocated before we exit the program free ( list ); return 0 ; } We can see it's troublesome if we handling this process ourselves. Therefore, C provides a function realloc , to reallocate some memory that we allocate earlier from heap areas using malloc . 1 int * tmp = realloc ( list , ( N + 1 ) * sizeof ( int )); And realloc copies our old array, list , for us into a bigger chunk of memory of the size we pass in. If there happens to be spaces after out existing chunk of memory, we'll get the same address back, but with the memory after it allocated to our variable as well.","title":"1.2. Implementing resizing arrays"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#2-data-structures","text":"Data structures are more complex ways to organize data in memory, allowing us to store information in different layouts . To build a data structure, we'll need some tools: struct to create custom data types . to access properties in a structure * to go to an address in memory pointed by a pointer -> to access properties in a struct pointed by a pointer","title":"2. Data structures"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#3-linked-list","text":"","title":"3. Linked list"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#31-what-is-linked-list","text":"With a linked list , we can store a list of values that can easily be grown by storing values in different parts of memory. E.g. we have the values 1 , 2 and 3 , each at some address in memory like 0x123 , 0x234 , and 0x345 , which are not contiguous addresses. So it's different than the array, that is we can use whatever locations in memory that are free.","title":"3.1. What is linked list"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#32-how-to-implement","text":"Due to these address are not contiguous in memory, we cannot track them by indexing addresses. So we need link our list together by allocating, for each element, enough memory for both the value we want to store, and the address of the next address . We'll call it a node , which a component of our data structure that stores both a value and a pointer. As we mentioned before, we'll implement out nodes with a structure . And notice that, the last node of linked list, we have the null pointer since there's no next element. When we need to insert another node, we just change the single null ptr to point our new node.","title":"3.2. How to implement"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#33-trade-off","text":"We have the trade off of needing to allocate twice as much memory for each element, in order to spend less time adding values. And we no longer can use binary search, which depends on the index of address yet our nodes might be anywhere in memory.","title":"3.3. Trade off"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#34-implementing-nodes","text":"Before we implement linked lists, we have to implement the component of linked lists, nodes . In code, we might want to create our own struct called node , and we need to store both our value, an int called number , and a pointer to the next node , called next . 1 2 3 4 5 typedef struct node { int number ; struct node * next ; } node ; Notice that we start with typedef struct node so that we can refer to a node inside our struct.","title":"3.4. Implementing nodes"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#35-implementing-linked-lists","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include <stdio.h> #include <stdlib.h> // Represent a node typedef struct node { int number ; struct node * next ; } node ; int main ( void ) { // List of size 0. We initialize the value to NULL explicitly, so there's no // garbage value for our list variable node * list = NULL : // Allocate memory for a node, n node * n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } // Set the value and pointer to our node n -> value = N ; n -> next = NULL : // Add node n by pointing list to it, since we only have one node so far list = n ; // Allocate memory for another node, and we can reuse our variable n to point // to it, since list points to the first node alraedy n = malloc ( sizeof ( node )); if ( n == NULL ) { free ( list ); return 1 ; } // Set the values in our new node n -> number = N ; n -> next = NULL ; // Update the pointer in our first node to point to the second node list -> next = n ; // Allocate memory for the third node n = malloc ( sizeof ( node )); if ( n == NULL ) { // free both of our other nodes free ( list -> next ); free ( list ); return 1 ; } // Follow the next pointer of the list to the second node, and update // the next pointer there to point to n list -> next -> next = n ; // Print list using a loop, by using a temporary variable, tmp, to point // to list, the first node. Then, every time we go over the loop, we use // tmp = tmp->next to update our temporary pointer to the next node. // We might keep going as tmp points somewhere, stopping when we get the last // node and tmp->next == null, namely there's no more nodes after this node. for ( node * tmp = list ; tmp != NULL ; tmp = tmp -> next ) { printf ( \"%i \\n \" , tmp -> number ); } // Free list, by using a while loop and a temporary variable to point to // the next node before freeing the current one. while ( list != NULL ) { // Point to the next node first node * tmp = list -> next ; // Then, free the first node free ( list ); // Now we can set the list point to the next node list = tmp ; } } If we want to insert a node to the front of our linked list, we should need to carefully update our node to point to the one following it, before updating the list variable. Otherwise, we'll lose the rest of our list. 1 2 3 4 // Here, we're inserting a node into the front of the list, so we want its next // pointer to point to the orginal list. Then we can change the list to point to n. n -> next = list ; list = n ; That is, at first we'll have a node with value 1 pointing to the start of our list, a node with value 2 . Now we can change our list variable to point to the node with value 1 , and not lost the rest of our list. Similarly, to insert a node into the middle of our list, we can change the next pointer of new node first to point to the rest of the list, then update the previous node to the new node. A linked list demonstrates how we can build flexible data structure in memory, though we're only visualizing it in one dimension .","title":"3.5. Implementing linked lists"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#4-tree","text":"","title":"4. Tree"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#41-what-is-tree","text":"With a sorted array, we can use binary search to find an element, starting at the middle (the yellow one), then the middle of either half (red), and finally left or right (green) as needed. With an array, we can randomly access elements in O(1) time, since we can use arithmetic to go to an element at any index. A tree is another data structure where each node points two other nodes, one to the left (with a smaller value) and one to the right (with a larger value). Notice that we now visualize this data structure in two dimensions (even though the nodes in memory can be at any location). And we can implement this with a more complex version of a node in a linked list, where each node has not one but two pointers to other nodes. All the value to the left of a node are smaller , and all the value to the right are greater, which allows this to be used as a binary search tree . And the data structure is itself defined recursively, so we can use recursive functions to work with it. Each node has at most two children, i.e. nodes it's pointing to.","title":"4.1. What is Tree"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#42-implementing-binary-search-tree","text":"Like a linked list, we'll want to keep a pointer to just the beginning of the list, but in this case we want to point to the root , or top center node of the tree ( 4 in this case). We can define a node with not one but two pointers: 1 2 3 4 5 6 typedef struct node { int number ; struct node * left ; struct node * right ; } node ; And write a function to recursively search a tree: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // tree is pointer to a node that is the root of the tree we're searching in. // number is a value we're trying to find in the tree. bool search ( node * tree , int value ) { // Fisrt, make sure that the tree isn't NULL, if we're reached a node on the // bottom, or if our tree is entirely empty. if ( tree == NULL ) { return false ; } // If we're looking for a number that's less than the tree's number, search the // left side, using the node on the left as the new tree. else if ( number < tree -> number ) { return search ( number , tree -> left ); } // Otherwise, search the right side, using the node on the right as the new tree. else if ( number > tree -> number ) { return search ( number , tree -> right ); } // Finally, we've found the number we've looking for, so we can return true. // We can simplify this to just \"else\", since there's no other case possible else if ( number == tree -> number ) { return true ; } }","title":"4.2. Implementing Binary Search Tree"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#43-trade-off","text":"With a binary search tree, we've incurred the cost of even more memory, since each node now needs space for a value and two pointers. Inserting a new value would take O(log n) time, since we need to find the nodes that it should go between. If we add enough nodes, though, our search tree might start to look like a linked list: That is, we started our tree with a node with value 1 , then added the node with value 2 , and finally added the node with value 3 . Even though this tree follows the constraints of a binary search tree, it's not as efficient as it could be. We can make this tree balanced, or optimal, by making the node with value 2 the new root node. More advanced courses will cover data structures and algorithms that help us keep trees balanced as nodes are added.","title":"4.3. Trade off"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#5-more-data-structures","text":"","title":"5. More data structures"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#51-hash-table","text":"A data structure with almost a constant time, O(1) search is a Hash table , which is essentially an array of linked lists . Each linked list in the array has elements of a certain category. E.g., we might have lots of names, and we might sort then into an array with 26 positions, one for each letter of the alphabet. Since we have random access with arrays, we can set elements and index into a location, or bucket, in the array quickly. A location might have multiple matching values, but we can add a value to another value since they're nodes in a linked list, as we see with Hermione, Harry, and Hagird. We don't need to grow the size of our array or move any of our other values. This is called hash table because we use a hash function , which takes some input and deterministically maps it to the location it should go in. In our example, the hash function just returns an index corresponding to the first letter of the name, such as 0 for \"Albus\" and 25 for \"Zacharias\". But in the worst case, all the names might start with the same letter, so we might end up with the equivalent of a single linked list again. We might look at the first two letters, and allocate enough buckets for 26*26 possible hashed values, or even the first three letters, requiring 26*26*26 buckets. Now, we're using more space in memory, since more of those buckets will be empty, but we're more likely to only need one step to look for a value, reducing our running time for search. To sort some standard playing cards, too, we might first start with putting them in piles by suit, of spades, diamonds, hearts, and clubs. Then, we can sort each pile a little more quickly. It turns out that the worst case running time for a hash table is O( n ), since, as n gets very large, each bucket will have on the order of n values, even if we have hundreds or thousands of buckets. In practice, though, our running time will be faster since we\u2019re dividing our values into multiple buckets.","title":"5.1. Hash table"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#52-trie","text":"We can use another data structure called a trie , (pronounced like \"try\", and is short for \"retrieval\"). A trie is a tree with arrays as nodes. In this case, each array will have each letter, A-Z, stored. For each word, the first letter will point to an array, where the next valid letter will point to another array, and so on, until we reach a boolean value indicating the end of a valid word, marked in green above. If our word isn\u2019t in the trie, then one of the arrays won\u2019t have a pointer or terminating character for our word. Now, let's consider the trade off for this data structure, even if our data structure has lots of words, the maximum lookup time will be just the length of the word we\u2019re looking for. This might be a fixed maximum, so we can have O (1) for searching and insertion. The cost for this, though, is that we need lots of memory to store pointers and boolean values as indicators of valid words, even though lots of them won\u2019t be used.","title":"5.2. Trie"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#53-abstract-data-structures","text":"There are even higher-level constructs, abstract data structures , where we use our building blocks of arrays, linked list, hash tables, and tries to implement a solution to some problem.","title":"5.3. Abstract data structures"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#54-queue","text":"For example, one abstract data structure is a queue , like a line of people waiting, where the first value we put in are the first values that are removed, or first-in-first-out (FIFO). To add a value we enqueue it, and to remove a value we dequeue it. This data structure is abstract because it\u2019s an idea that we can implement in different ways: with an array that we resize as we add and remove items, or with a linked list where we append values to the end.","title":"5.4. queue"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#55-stack","text":"An \u201copposite\u201d data structure would be a stack , where items most recently added are removed first: last-in-first-out (LIFO). At a clothing store, we might take, or pop , the top sweater from a stack, and new sweaters would be added, or pushed , to the top as well.","title":"5.5. Stack"},{"location":"notes/Harvard_CS50/0x05_Data_Structures/#56-dictionary","text":"Another example of an abstract data structure is a dictionary , where we can map keys to values, such as words to their definitions. We can implement one with a hash table or an array, taking into account the tradeoff between time and space.","title":"5.6. Dictionary"},{"location":"notes/Harvard_CS50/0x06_Python/","text":"1. Python basics 1.1. What is Python Python is a programming language, which is a newer language than C , it has additional features as well as simplicity, leading to its popularity. 1.2. Hello World Source code in Python looks a lot simpler than C. In fact, to print \"Hello World\" just like what we've done in C, all we need to write is: 1 print ( \"Hello World\" ) Notice that, unlike in C, we don't need to specify a newline in the print function or use a semicolon to end our line. Furthermore, to write and run this program, we'll just save this source code file as hello.py , and run the command python hello.py without any compilation. 1.3. Input & Output We can get input from user, such as string : 1 2 answer = get_string ( \"What's your name? \" ) print ( \"hello, \" + answer ) We also need to import the Python version of the CS50 library with import cs50 , where get_string function is in it, similar to #include <cs50.h> in C. But in this case, we need to import this way: from cs50 import get_string , we'll explain it later. Notice that, we create a variable called answer without specifying any type , and we can combine, or concatenate , two strings with the + operator before we pass it into print . We can also use the syntax for format strings in output , f\"...{variable}...\" to plug in variables. E.g., we could have written print(f\"hello, {answer}\") to plug in the value of answer into our string by surrounding it with curly braces . 1.4. Implicitly setting the type We can create variables with just counter = 0 . By assigning the value of 0 , we're implicitly setting the type of counter to an integer, so we don't need to specify the type. To increment a integer variable, we can use counter = counter + 1 or counter += 1 like C, but there's no counter++ in Python. 1.5. Conditions and Boolean expressions Conditions look like: 1 2 3 4 5 6 if x < y : print ( \"x is less than y\" ) elif x > y : print ( \"x is greater than y\" ) else : print ( \"x is equal to y\" ) Unlike in C, where curly braces are used to indicate blocks of code, the exact indentation of each line is what determines the level of nesting in Python. And instead of else if , just elif . Boolean expressions are slightly different, too: 1 2 while True : print ( \"True instead of true\" ) Both True and False are capitalized in Python 1.6. Loops We can write a loop with a variable: 1 2 3 4 i = 0 while i < 3 : print ( f \"now i is { i } \" ) i += 1 We can also use a for loop, where we can do something for each value in a list: 1 2 for i in [ 0 , 1 , 2 ]: print ( \"hi\" ) List in Python, [0, 1, 2] , are like arrays in C. But if the number of loop becomes larger, this way gonna be inelegant. Instead, we can use a specific function called range(n) , which will give us a list from 0 up to n but exclude n , with the values of 0, 1, ..., n - 1 . 1 2 for i in range ( 3 ): print ( \"elegant\" ) range() function takes other options as well, so we can have lists that start at different values and have different increments between values. E.g., range(10, 101, 2) means give us a sequence of number start from 10 up to 101 but exclude 101 , incrementing by 2 at a time. 1.7. Pythonic Since there are often multiple ways to write the same code in Python, the most commonly used and accepted ways are called Pythonic . 1.8. Built-in data types and Loosely typed In Python, there're many built-in data types : bool , Boolean values, either True or False float , real numbers int , integers str , strings While C is a strongly typed language, where we need to specify types, Python is a loosely typed language, where the type is implied by the values we assigned. Other types in Python include: range , sequence of numbers list , sequence of mutable values, or values we can change And list, even though they're arrays in C, can grow and shrink automatically in Python tuple , collection of ordered values like x- and y-coordinates, or longitude and latitude dict , dictionaries, collection of key-value pairs, like a hash table set , collection of unique values, or values without duplicates 1.9. CS50 library The CS50 library for Python include: get_float get_int get_string As we mentioned, we can import one at a time: 1 2 3 from cs50 import get_float from cs50 import get_int from cs50 import get_string or all together: 1 from cs50 import get_float , get_int , get_string or import the whole library: 1 import cs50 If our program needed to import two different libraries, each with a get_int function, for example, we would need to use this method to namespace functions, keeping their names in different spaces to prevent them from colliding. 2. Details 2.1. Use others' libraries Since Python includes many features as well as libraries of code written by others, we can solve problem at a higher level of abstraction , instead of implementing all the details ourselves. There's some differences between C and Python in using libraries. E.g., we can blur an image with: 1 2 3 4 5 6 7 8 from PIL import Image , ImageFilter # Open an image called \"bridge.bmp\" before = Image . open ( \"bridge.bmp\" ) # Call a bulr filter function after = before . filter ( ImageFilter . BoxBlur ( 1 )) # Save it to a file called \"out.bmp\" after . save ( \"out.bmp\" ) In Python, we include other libraries with import just as we mentioned last chapter, and here we'll import the Image and ImageFilter from PIL library. (Other people have written this library, among others, and made it available for all of us download and use.) Image is a structure that not only has data, but functions that we can access with the . operator, such as with Image.open() . Finally, we can run this with python blur.py after saving to a file called blur.py . 2.2. Interpreter We can implement a dictionary like we did in week 5 with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # Create a new set called words words = set () # Define a function called load def load ( dictionary ): # open dictionary with read mode as variable \"file\" file = open ( dictionary , \"r\" ) # iterate over the lines in file for line in file : # remove the newline character at the end of line with .rstrip() words . add ( line . rstrip ()) file . close () return True def check ( word ): # check if the word in the words if word . lower () in words : return True else : return False def size (): # we can use len() function get the length of an array(or a set) directly return len ( words ) def unload (): # There is no longer memory management like malloc() and free() # so it gonna be always True return True It turns out, even though implementing a program in Python is simpler for us, the running time in Python is slower in C since the language has to do more work for us with general-propose solutions, like for memory management. In addition, Python is also the name of a program called an interpreter , which reads in our source code and translates it to code that our CPU (Central Processing Unit) can understand, line by line, like machine code compiled by a compiler in C. E.g., consider that there is a text written in Spanish, and you can't understand Spanish, if we translate it into English, we probably could read it as fast as usual; but if we only have a Spanish-English dictionary, we have to look up every word of this text in dictionary, which gonna be very slow. So, depending on our goals, we'll also have to consider the trade-off of human time of writing a program that's more efficient, versus the running time of the program. 2.3. Input We can get input from the user with the input function without using CS50 library: 1 2 answer = input ( \"What's your name? \" ) print ( f \"Hello, { answer } \" ) Also we can ask the user for two integers using input function and add them: 1 2 3 4 5 6 x = input ( \"Integer x: \" ) # x = 1 y = input ( \"Integer x: \" ) # y = 3 print ( x + y ) # output is 13 (it's a string) Notice that comments starts with # instead of The input function give us back strings for our values, to fix this we need to cast , or convert, each value from input into an int before we store it: 1 2 3 4 5 6 7 8 # Prompt user for x x = int ( input ( \"x: \" )) # Prompt user for y y = int ( input ( \"y: \" )) # Perform addition print ( x + y ) But if user didn't type in a number, we'll need to do even more error-checking or our program will crash. So we will generally want to use a commonly used library to solve problems like this. 2.4. Divisions and String comparisons We can divide values with: 1 2 3 4 5 6 7 8 # Prompt user for x x = int ( input ( \"x: \" )) # Prompt user for y y = int ( input ( \"y: \" )) # Perform division print ( x / y ) We won't get truncation just like in C, but a floating-point, decimal value back, even if we divided two integers. To compare strings, we can say: 1 2 3 4 5 6 7 8 from cs50 import get_string s = get_string ( \"Do you agree? \" ) if s == \"Y\" or s == \"y\" : print ( \"Agreed.\" ) elif s == \"N\" or s == \"n\" : print ( \"Not agreed.\" ) Python doesn't have char , so we check Y and other letters as strings . We can also compare strings directly with == since there're no longer pointers in Python. In our boolean expressions, we use or and and instead of symbols like && and || . We can also say if s.lower() in [\"y\", \"yes\"]: to check if our string is in a list, after converting it to lowercase first. 2.5. Functions and the Main function Recall that we implemented and improved the meow() function in C, we can improve versions of meow too. 1 2 3 print ( \"meow\" ) print ( \"meow\" ) print ( \"meow\" ) We can define a function that we can reuse: 1 2 3 4 5 for i in range ( 3 ): meow () def meow (): print ( \"meow\" ) But this causes an error when we try to run it: NameError: name 'meow' is not defined. It turns out that we need to define a function before we use it, so we can either move our definition of meow() function to the top, or define a main() function first. 1 2 3 4 5 6 7 8 def main (): for in in range ( 3 ): meow () def meow (): print ( \"meow\" ) main () Now, by the time we actually call our main function, the meow function will already have been defined. Our functions could take inputs, too: 1 2 3 4 5 6 7 8 def main (): meow ( 3 ) def meow ( times ): for i in range ( times ): print ( \"meow\" ) main () 2.6. Variables scope We can define a function to get a positive integer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from cs50 import get_int def main (): i = get_positive_int () print ( i ) def get_positive_int (): while True : n = get_int ( \"Positive integer: \" ) if n > 0 : break return n main () Since there's no do-while loop in Python as there is in C, we have a while loop that will go on infinitely, and use break to end the loop as soon as n > 0 . Finally, our function will return n , at our original indentation level, outside of the while loop. Notice that, the variables in Python are scoped to functions by default, meaning that n can be initialized within a loop, but still be accessible later in the function. 1 2 3 4 for i in range ( 3 ): print ( i ) # the variable i is still accessible print ( i ) 2.7. Named arguments We can print out a row of question marks on the screen: 1 2 3 4 5 for i in range ( 4 ): # named argument \"end = \" print ( \"?\" , end = \"\" ) # add a newline print () It turns out that print() function will print a newline character automatically by default, if we don't want the automatic new line, we can pass a named argument , also known as keyword argument, to the print function, which specifies the value for a specify parameter. So far, we've only seen positional arguments , where parameters are set based on their position in the function call just like in C. Here, we say end=\"\" to specify that nothing should be printed at the end of our string. end is also an optional argument , one we don't need pass in, with a default value of \\n , which is why print usually adds a new line for us. We can also \"multiply\" a string and print that directly with print(\"?\" * 4) . 2.8. Overflow, Imprecision In Python, trying to cause an integer overflow actually won\u2019t work: 1 2 3 4 i = 1 while True : print ( i ) i *= 2 We see larger and larger numbers being printed, since Python automatically uses more and more memory to store numbers for us, unlike C where integers are fixed to a certain number of bytes. Floating-point imprecision, too, still exists , but can be prevented by libraries that can represent decimal numbers with as many bits as are needed. 2.9. Lists, strings We can make a list: 1 2 3 scores = [ 72 , 73 , 33 ] print ( \"Average: \" + str ( sum ( scores ) / len ( scores ))) We can use sum , a function built into Python, to add up the values in our list, and divide it by the number of scores, using the len function to get the length of the list. Then, we cast the float to a string before we can concatenate and print it. We can even add the entire expression into a formatted string for the same effect: 1 print ( f \"Average: { sum ( scores ) / len ( scores ) } \" ) We can add items to a list with: 1 2 3 4 5 6 from cs50 import get_int scores = [] for i in range ( 3 ): scores . append ( get_int ( \"Score: \" )) ... We can iterate over each character in a string: 1 2 3 4 5 6 7 from cs50 import get_string s = get_string ( \"Before: \" ) print ( \"After: \" , end = \"\" ) for c in s : print ( c . upper (), end = \"\" ) print () Python will iterate over each character in the string for us with just for c in s . To make a string uppercase, we can also just call s.upper() , without having to iterate over each character ourselves. 2.10. Command-line arguments, exit codes We can take command-line arguments with: 1 2 3 4 5 6 from sys import argv if len ( argv ) == 2 : print ( f \"hello, { argv [ 1 ] } \" ) else : print ( \"Hello, World\" ) We import argv from sys , or system module, built into Python. Since argv is a list, we can get the second item with argv[1] . Like in C, argv[0] would be the name of our program, like argv.py . We can return exit codes when our program exits, too: 1 2 3 4 5 6 7 8 import sys if len ( argv ) != 2 : print ( \"Missing command-line argument.\" ) # same as return 1 in C sys . exit ( 1 ) print ( f \"hello, { world } \" ) sys . exit ( 0 ) We import the entire sys module now, since we\u2019re using multiple components of it. Now we can use sys.argv and sys.exit() to exit our program with a specific code. 2.11. Algorithms We can implement linear search by just checking each element in a list: 1 2 3 4 5 6 7 8 9 10 import sys number = [ 4 , 6 , 8 , 9 , 0 , 10 , 12 ] if 0 in number : print ( \"Found.\" ) sys . exit ( 0 ) print ( \"Not found.\" ) sys . exit ( 1 ) With if 0 in numbers: , we\u2019re asking Python to check the list for us. A list of strings, too, can be searched with: 1 2 3 4 5 6 names = [ \"Bill\" , \"Charlie\" , \"Fred\" , \"George\" , \"Ginny\" , \"Percy\" , \"Ron\" ] if \"Ron\" in names : print ( \"Found\" ) else : print ( \"Not found\" ) If we have a dictionary, a set of key-value pairs, we can also check for a particular key, and look at the value stored for it: 1 2 3 4 5 6 7 8 9 10 from cs50 import get_string people = { \"Brian\" : \"+1-617-495-1000\" , \"David\" : \"+1-949-468-2750\" } name = get_string ( \"Name: \" ) if name in people : print ( f \"Number: { people [ name ] } \" ) We first declare a dictionary, people , where the keys are strings of each name we want to store, and the value we want to associate with each key is a string of a corresponding phone number. Then, we use if name in people: to search the keys of our dictionary for a name . If the key exists, then we can get the value with the bracket notation, people[name] , much like indexing into an array with C, except here we use a string instead of an integer. Dictionaries, as well as sets, are typically implemented in Python with a data structure like a hash table, so we can have close to constant time lookup. Again, we have the tradeoff of having less control over exactly what happens under the hood, like being able to choose a hash function, with the benefit of having to do less work ourselves. Swapping two variables can also be done simply by assigning both values at the same time: 1 2 3 4 5 6 x = 1 y = 2 print ( f \"x is { x } , y is { y } \" ) x , y = y , x print ( f \"x is { x } , y is { y } \" ) In Python, we don\u2019t have access to pointers, which protects us from making mistakes with memory. 3. Files 3.1. CSV file Let's open a CSV file (comma-separated values): 1 2 3 4 5 6 7 8 9 10 11 12 13 import csv from cs50 import get_string file = open ( \"phonebook.csv\" , \"a\" ) name = get_string ( \"Name: \" ) number = get_string ( \"Number: \" ) writer = csv . writer ( file ) writer . writerow ([ name , number ]) file . close () It turns out that Python also has a csv library that helps us work with CSV files, so after we open the file for a ppending, we can call csv.writer to create a writer from the file, which gives additional functionality, like writer.writerow to write a list as row. 3.2. with and as keyword We can use the with keyword, which will close the file for us after we're finished. 1 2 3 4 # after get name and number from user's input with open ( \"phonebook.csv\" , \"a\" ) as file : writer = csv . writer ( file ) writer . writerow (( name , number )) We can open another CSV file, tallying the number of times a value appears: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import csv houses = { \"Gryffindor\" : 0 , \"Hufflepuff\" : 0 , \"Ravenclaw\" : 0 , \"Slytherin\" : 0 } with open ( \"Sorting Hat (Responses) - Form Responses 1.csv\" , \"r\" ) as file : reader = csv . reader ( file ) next ( reader ) for row in reader : house = row [ 1 ] houses [ house ] += 1 for house in houses : print ( f \" { house } : { houses [ house ] } \" ) We use the reader function from the csv library, skip the header row with next(reader) , and then iterate over each of the rest of the rows. The second item in each row, row[1] , is the string of a house, so we can use that to access the value stored in houses for that key, and add one to it. Finally, we\u2019ll print out the count for each house. 3. More libraries 3.1. pyttsx3 library On our own Mac or PC, we can open a terminal after installing Python, and use another library to convert text to speech: 1 2 3 4 5 import pyttsx3 engine = pyttsx3 . init () engine . say ( \"hello, world\" ) engine . runAndWait () By reading the documentation, we can figure out how to initialize the library, and say a string. We can even pass in a format string with engine.say(f\"hello, {name}\") to say some input. 3.2. face_recognition We can use another library, face_recognition , to find faces in images: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # Find faces in picture # https://github.com/ageitgey/face_recognition/blob/master/examples/find_faces_in_picture.py from PIL import Image import face_recognition # Load the jpg file into a numpy array image = face_recognition . load_image_file ( \"office.jpg\" ) # Find all the faces in the image using the default HOG-based model. # This method is fairly accurate, but not as accurate as the CNN model and not GPU accelerated. # See also: find_faces_in_picture_cnn.py face_locations = face_recognition . face_locations ( image ) for face_location in face_locations : # Print the location of each face in this image top , right , bottom , left = face_location # You can access the actual face itself like this: face_image = image [ top : bottom , left : right ] pil_image = Image . fromarray ( face_image ) pil_image . show () With recognize.py , we can write a program that finds a match for a particular face. 3.3. qrcode We can create a QR code, or two-dimensional barcode, with another library: 1 2 3 4 5 6 import os import qrcode img = qrcode . make ( \"https://youtu.be/oHg5SJYRHA0\" ) img . save ( \"qr.png\" , \"PNG\" ) os . system ( \"open qr.png\" ) 3.4. speech_recognition We can recognize audio input from a microphone: 1 2 3 4 5 6 7 8 9 10 11 import speech_recognition # Obtain audio from the microphone recognizer = speech_recognition . Recognizer () with speech_recognition . Microphone () as source : print ( \"Say something:\" ) audio = recognizer . listen ( source ) # Recognize speech using Google Speech Recognition print ( \"You said:\" ) print ( recognizer . recognize_google ( audio )) We\u2019re following the documentation of the library to listen to our microphone and convert it to text. 1 2 3 4 5 6 7 8 9 10 11 12 ... words = recognizer . recognize_google ( audio ) # Respond to speech if \"hello\" in words : print ( \"Hello to you too!\" ) elif \"how are you\" in words : print ( \"I am well, thanks!\" ) elif \"goodbye\" in words : print ( \"Goodbye to you too!\" ) else : print ( \"Huh?\" ) Finally, we use another, more sophisticated program to generate deepfakes, or realistic-appearing but computer-generated videos of various personalities. By taking advantage of all these libraries that are freely available online, we can easily add advanced functionality to our own applications.","title":"Lec 06: Python"},{"location":"notes/Harvard_CS50/0x06_Python/#1-python-basics","text":"","title":"1. Python basics"},{"location":"notes/Harvard_CS50/0x06_Python/#11-what-is-python","text":"Python is a programming language, which is a newer language than C , it has additional features as well as simplicity, leading to its popularity.","title":"1.1. What is Python"},{"location":"notes/Harvard_CS50/0x06_Python/#12-hello-world","text":"Source code in Python looks a lot simpler than C. In fact, to print \"Hello World\" just like what we've done in C, all we need to write is: 1 print ( \"Hello World\" ) Notice that, unlike in C, we don't need to specify a newline in the print function or use a semicolon to end our line. Furthermore, to write and run this program, we'll just save this source code file as hello.py , and run the command python hello.py without any compilation.","title":"1.2. Hello World"},{"location":"notes/Harvard_CS50/0x06_Python/#13-input-output","text":"We can get input from user, such as string : 1 2 answer = get_string ( \"What's your name? \" ) print ( \"hello, \" + answer ) We also need to import the Python version of the CS50 library with import cs50 , where get_string function is in it, similar to #include <cs50.h> in C. But in this case, we need to import this way: from cs50 import get_string , we'll explain it later. Notice that, we create a variable called answer without specifying any type , and we can combine, or concatenate , two strings with the + operator before we pass it into print . We can also use the syntax for format strings in output , f\"...{variable}...\" to plug in variables. E.g., we could have written print(f\"hello, {answer}\") to plug in the value of answer into our string by surrounding it with curly braces .","title":"1.3. Input &amp; Output"},{"location":"notes/Harvard_CS50/0x06_Python/#14-implicitly-setting-the-type","text":"We can create variables with just counter = 0 . By assigning the value of 0 , we're implicitly setting the type of counter to an integer, so we don't need to specify the type. To increment a integer variable, we can use counter = counter + 1 or counter += 1 like C, but there's no counter++ in Python.","title":"1.4. Implicitly setting the type"},{"location":"notes/Harvard_CS50/0x06_Python/#15-conditions-and-boolean-expressions","text":"Conditions look like: 1 2 3 4 5 6 if x < y : print ( \"x is less than y\" ) elif x > y : print ( \"x is greater than y\" ) else : print ( \"x is equal to y\" ) Unlike in C, where curly braces are used to indicate blocks of code, the exact indentation of each line is what determines the level of nesting in Python. And instead of else if , just elif . Boolean expressions are slightly different, too: 1 2 while True : print ( \"True instead of true\" ) Both True and False are capitalized in Python","title":"1.5. Conditions and Boolean expressions"},{"location":"notes/Harvard_CS50/0x06_Python/#16-loops","text":"We can write a loop with a variable: 1 2 3 4 i = 0 while i < 3 : print ( f \"now i is { i } \" ) i += 1 We can also use a for loop, where we can do something for each value in a list: 1 2 for i in [ 0 , 1 , 2 ]: print ( \"hi\" ) List in Python, [0, 1, 2] , are like arrays in C. But if the number of loop becomes larger, this way gonna be inelegant. Instead, we can use a specific function called range(n) , which will give us a list from 0 up to n but exclude n , with the values of 0, 1, ..., n - 1 . 1 2 for i in range ( 3 ): print ( \"elegant\" ) range() function takes other options as well, so we can have lists that start at different values and have different increments between values. E.g., range(10, 101, 2) means give us a sequence of number start from 10 up to 101 but exclude 101 , incrementing by 2 at a time.","title":"1.6. Loops"},{"location":"notes/Harvard_CS50/0x06_Python/#17-pythonic","text":"Since there are often multiple ways to write the same code in Python, the most commonly used and accepted ways are called Pythonic .","title":"1.7. Pythonic"},{"location":"notes/Harvard_CS50/0x06_Python/#18-built-in-data-types-and-loosely-typed","text":"In Python, there're many built-in data types : bool , Boolean values, either True or False float , real numbers int , integers str , strings While C is a strongly typed language, where we need to specify types, Python is a loosely typed language, where the type is implied by the values we assigned. Other types in Python include: range , sequence of numbers list , sequence of mutable values, or values we can change And list, even though they're arrays in C, can grow and shrink automatically in Python tuple , collection of ordered values like x- and y-coordinates, or longitude and latitude dict , dictionaries, collection of key-value pairs, like a hash table set , collection of unique values, or values without duplicates","title":"1.8. Built-in data types and Loosely typed"},{"location":"notes/Harvard_CS50/0x06_Python/#19-cs50-library","text":"The CS50 library for Python include: get_float get_int get_string As we mentioned, we can import one at a time: 1 2 3 from cs50 import get_float from cs50 import get_int from cs50 import get_string or all together: 1 from cs50 import get_float , get_int , get_string or import the whole library: 1 import cs50 If our program needed to import two different libraries, each with a get_int function, for example, we would need to use this method to namespace functions, keeping their names in different spaces to prevent them from colliding.","title":"1.9. CS50 library"},{"location":"notes/Harvard_CS50/0x06_Python/#2-details","text":"","title":"2. Details"},{"location":"notes/Harvard_CS50/0x06_Python/#21-use-others-libraries","text":"Since Python includes many features as well as libraries of code written by others, we can solve problem at a higher level of abstraction , instead of implementing all the details ourselves. There's some differences between C and Python in using libraries. E.g., we can blur an image with: 1 2 3 4 5 6 7 8 from PIL import Image , ImageFilter # Open an image called \"bridge.bmp\" before = Image . open ( \"bridge.bmp\" ) # Call a bulr filter function after = before . filter ( ImageFilter . BoxBlur ( 1 )) # Save it to a file called \"out.bmp\" after . save ( \"out.bmp\" ) In Python, we include other libraries with import just as we mentioned last chapter, and here we'll import the Image and ImageFilter from PIL library. (Other people have written this library, among others, and made it available for all of us download and use.) Image is a structure that not only has data, but functions that we can access with the . operator, such as with Image.open() . Finally, we can run this with python blur.py after saving to a file called blur.py .","title":"2.1. Use others' libraries"},{"location":"notes/Harvard_CS50/0x06_Python/#22-interpreter","text":"We can implement a dictionary like we did in week 5 with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # Create a new set called words words = set () # Define a function called load def load ( dictionary ): # open dictionary with read mode as variable \"file\" file = open ( dictionary , \"r\" ) # iterate over the lines in file for line in file : # remove the newline character at the end of line with .rstrip() words . add ( line . rstrip ()) file . close () return True def check ( word ): # check if the word in the words if word . lower () in words : return True else : return False def size (): # we can use len() function get the length of an array(or a set) directly return len ( words ) def unload (): # There is no longer memory management like malloc() and free() # so it gonna be always True return True It turns out, even though implementing a program in Python is simpler for us, the running time in Python is slower in C since the language has to do more work for us with general-propose solutions, like for memory management. In addition, Python is also the name of a program called an interpreter , which reads in our source code and translates it to code that our CPU (Central Processing Unit) can understand, line by line, like machine code compiled by a compiler in C. E.g., consider that there is a text written in Spanish, and you can't understand Spanish, if we translate it into English, we probably could read it as fast as usual; but if we only have a Spanish-English dictionary, we have to look up every word of this text in dictionary, which gonna be very slow. So, depending on our goals, we'll also have to consider the trade-off of human time of writing a program that's more efficient, versus the running time of the program.","title":"2.2. Interpreter"},{"location":"notes/Harvard_CS50/0x06_Python/#23-input","text":"We can get input from the user with the input function without using CS50 library: 1 2 answer = input ( \"What's your name? \" ) print ( f \"Hello, { answer } \" ) Also we can ask the user for two integers using input function and add them: 1 2 3 4 5 6 x = input ( \"Integer x: \" ) # x = 1 y = input ( \"Integer x: \" ) # y = 3 print ( x + y ) # output is 13 (it's a string) Notice that comments starts with # instead of The input function give us back strings for our values, to fix this we need to cast , or convert, each value from input into an int before we store it: 1 2 3 4 5 6 7 8 # Prompt user for x x = int ( input ( \"x: \" )) # Prompt user for y y = int ( input ( \"y: \" )) # Perform addition print ( x + y ) But if user didn't type in a number, we'll need to do even more error-checking or our program will crash. So we will generally want to use a commonly used library to solve problems like this.","title":"2.3. Input"},{"location":"notes/Harvard_CS50/0x06_Python/#24-divisions-and-string-comparisons","text":"We can divide values with: 1 2 3 4 5 6 7 8 # Prompt user for x x = int ( input ( \"x: \" )) # Prompt user for y y = int ( input ( \"y: \" )) # Perform division print ( x / y ) We won't get truncation just like in C, but a floating-point, decimal value back, even if we divided two integers. To compare strings, we can say: 1 2 3 4 5 6 7 8 from cs50 import get_string s = get_string ( \"Do you agree? \" ) if s == \"Y\" or s == \"y\" : print ( \"Agreed.\" ) elif s == \"N\" or s == \"n\" : print ( \"Not agreed.\" ) Python doesn't have char , so we check Y and other letters as strings . We can also compare strings directly with == since there're no longer pointers in Python. In our boolean expressions, we use or and and instead of symbols like && and || . We can also say if s.lower() in [\"y\", \"yes\"]: to check if our string is in a list, after converting it to lowercase first.","title":"2.4. Divisions and String comparisons"},{"location":"notes/Harvard_CS50/0x06_Python/#25-functions-and-the-main-function","text":"Recall that we implemented and improved the meow() function in C, we can improve versions of meow too. 1 2 3 print ( \"meow\" ) print ( \"meow\" ) print ( \"meow\" ) We can define a function that we can reuse: 1 2 3 4 5 for i in range ( 3 ): meow () def meow (): print ( \"meow\" ) But this causes an error when we try to run it: NameError: name 'meow' is not defined. It turns out that we need to define a function before we use it, so we can either move our definition of meow() function to the top, or define a main() function first. 1 2 3 4 5 6 7 8 def main (): for in in range ( 3 ): meow () def meow (): print ( \"meow\" ) main () Now, by the time we actually call our main function, the meow function will already have been defined. Our functions could take inputs, too: 1 2 3 4 5 6 7 8 def main (): meow ( 3 ) def meow ( times ): for i in range ( times ): print ( \"meow\" ) main ()","title":"2.5. Functions and the Main function"},{"location":"notes/Harvard_CS50/0x06_Python/#26-variables-scope","text":"We can define a function to get a positive integer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from cs50 import get_int def main (): i = get_positive_int () print ( i ) def get_positive_int (): while True : n = get_int ( \"Positive integer: \" ) if n > 0 : break return n main () Since there's no do-while loop in Python as there is in C, we have a while loop that will go on infinitely, and use break to end the loop as soon as n > 0 . Finally, our function will return n , at our original indentation level, outside of the while loop. Notice that, the variables in Python are scoped to functions by default, meaning that n can be initialized within a loop, but still be accessible later in the function. 1 2 3 4 for i in range ( 3 ): print ( i ) # the variable i is still accessible print ( i )","title":"2.6. Variables scope"},{"location":"notes/Harvard_CS50/0x06_Python/#27-named-arguments","text":"We can print out a row of question marks on the screen: 1 2 3 4 5 for i in range ( 4 ): # named argument \"end = \" print ( \"?\" , end = \"\" ) # add a newline print () It turns out that print() function will print a newline character automatically by default, if we don't want the automatic new line, we can pass a named argument , also known as keyword argument, to the print function, which specifies the value for a specify parameter. So far, we've only seen positional arguments , where parameters are set based on their position in the function call just like in C. Here, we say end=\"\" to specify that nothing should be printed at the end of our string. end is also an optional argument , one we don't need pass in, with a default value of \\n , which is why print usually adds a new line for us. We can also \"multiply\" a string and print that directly with print(\"?\" * 4) .","title":"2.7. Named arguments"},{"location":"notes/Harvard_CS50/0x06_Python/#28-overflow-imprecision","text":"In Python, trying to cause an integer overflow actually won\u2019t work: 1 2 3 4 i = 1 while True : print ( i ) i *= 2 We see larger and larger numbers being printed, since Python automatically uses more and more memory to store numbers for us, unlike C where integers are fixed to a certain number of bytes. Floating-point imprecision, too, still exists , but can be prevented by libraries that can represent decimal numbers with as many bits as are needed.","title":"2.8. Overflow, Imprecision"},{"location":"notes/Harvard_CS50/0x06_Python/#29-lists-strings","text":"We can make a list: 1 2 3 scores = [ 72 , 73 , 33 ] print ( \"Average: \" + str ( sum ( scores ) / len ( scores ))) We can use sum , a function built into Python, to add up the values in our list, and divide it by the number of scores, using the len function to get the length of the list. Then, we cast the float to a string before we can concatenate and print it. We can even add the entire expression into a formatted string for the same effect: 1 print ( f \"Average: { sum ( scores ) / len ( scores ) } \" ) We can add items to a list with: 1 2 3 4 5 6 from cs50 import get_int scores = [] for i in range ( 3 ): scores . append ( get_int ( \"Score: \" )) ... We can iterate over each character in a string: 1 2 3 4 5 6 7 from cs50 import get_string s = get_string ( \"Before: \" ) print ( \"After: \" , end = \"\" ) for c in s : print ( c . upper (), end = \"\" ) print () Python will iterate over each character in the string for us with just for c in s . To make a string uppercase, we can also just call s.upper() , without having to iterate over each character ourselves.","title":"2.9. Lists, strings"},{"location":"notes/Harvard_CS50/0x06_Python/#210-command-line-arguments-exit-codes","text":"We can take command-line arguments with: 1 2 3 4 5 6 from sys import argv if len ( argv ) == 2 : print ( f \"hello, { argv [ 1 ] } \" ) else : print ( \"Hello, World\" ) We import argv from sys , or system module, built into Python. Since argv is a list, we can get the second item with argv[1] . Like in C, argv[0] would be the name of our program, like argv.py . We can return exit codes when our program exits, too: 1 2 3 4 5 6 7 8 import sys if len ( argv ) != 2 : print ( \"Missing command-line argument.\" ) # same as return 1 in C sys . exit ( 1 ) print ( f \"hello, { world } \" ) sys . exit ( 0 ) We import the entire sys module now, since we\u2019re using multiple components of it. Now we can use sys.argv and sys.exit() to exit our program with a specific code.","title":"2.10. Command-line arguments, exit codes"},{"location":"notes/Harvard_CS50/0x06_Python/#211-algorithms","text":"We can implement linear search by just checking each element in a list: 1 2 3 4 5 6 7 8 9 10 import sys number = [ 4 , 6 , 8 , 9 , 0 , 10 , 12 ] if 0 in number : print ( \"Found.\" ) sys . exit ( 0 ) print ( \"Not found.\" ) sys . exit ( 1 ) With if 0 in numbers: , we\u2019re asking Python to check the list for us. A list of strings, too, can be searched with: 1 2 3 4 5 6 names = [ \"Bill\" , \"Charlie\" , \"Fred\" , \"George\" , \"Ginny\" , \"Percy\" , \"Ron\" ] if \"Ron\" in names : print ( \"Found\" ) else : print ( \"Not found\" ) If we have a dictionary, a set of key-value pairs, we can also check for a particular key, and look at the value stored for it: 1 2 3 4 5 6 7 8 9 10 from cs50 import get_string people = { \"Brian\" : \"+1-617-495-1000\" , \"David\" : \"+1-949-468-2750\" } name = get_string ( \"Name: \" ) if name in people : print ( f \"Number: { people [ name ] } \" ) We first declare a dictionary, people , where the keys are strings of each name we want to store, and the value we want to associate with each key is a string of a corresponding phone number. Then, we use if name in people: to search the keys of our dictionary for a name . If the key exists, then we can get the value with the bracket notation, people[name] , much like indexing into an array with C, except here we use a string instead of an integer. Dictionaries, as well as sets, are typically implemented in Python with a data structure like a hash table, so we can have close to constant time lookup. Again, we have the tradeoff of having less control over exactly what happens under the hood, like being able to choose a hash function, with the benefit of having to do less work ourselves. Swapping two variables can also be done simply by assigning both values at the same time: 1 2 3 4 5 6 x = 1 y = 2 print ( f \"x is { x } , y is { y } \" ) x , y = y , x print ( f \"x is { x } , y is { y } \" ) In Python, we don\u2019t have access to pointers, which protects us from making mistakes with memory.","title":"2.11. Algorithms"},{"location":"notes/Harvard_CS50/0x06_Python/#3-files","text":"","title":"3. Files"},{"location":"notes/Harvard_CS50/0x06_Python/#31-csv-file","text":"Let's open a CSV file (comma-separated values): 1 2 3 4 5 6 7 8 9 10 11 12 13 import csv from cs50 import get_string file = open ( \"phonebook.csv\" , \"a\" ) name = get_string ( \"Name: \" ) number = get_string ( \"Number: \" ) writer = csv . writer ( file ) writer . writerow ([ name , number ]) file . close () It turns out that Python also has a csv library that helps us work with CSV files, so after we open the file for a ppending, we can call csv.writer to create a writer from the file, which gives additional functionality, like writer.writerow to write a list as row.","title":"3.1. CSV file"},{"location":"notes/Harvard_CS50/0x06_Python/#32-with-and-as-keyword","text":"We can use the with keyword, which will close the file for us after we're finished. 1 2 3 4 # after get name and number from user's input with open ( \"phonebook.csv\" , \"a\" ) as file : writer = csv . writer ( file ) writer . writerow (( name , number )) We can open another CSV file, tallying the number of times a value appears: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import csv houses = { \"Gryffindor\" : 0 , \"Hufflepuff\" : 0 , \"Ravenclaw\" : 0 , \"Slytherin\" : 0 } with open ( \"Sorting Hat (Responses) - Form Responses 1.csv\" , \"r\" ) as file : reader = csv . reader ( file ) next ( reader ) for row in reader : house = row [ 1 ] houses [ house ] += 1 for house in houses : print ( f \" { house } : { houses [ house ] } \" ) We use the reader function from the csv library, skip the header row with next(reader) , and then iterate over each of the rest of the rows. The second item in each row, row[1] , is the string of a house, so we can use that to access the value stored in houses for that key, and add one to it. Finally, we\u2019ll print out the count for each house.","title":"3.2. with and as keyword"},{"location":"notes/Harvard_CS50/0x06_Python/#3-more-libraries","text":"","title":"3. More libraries"},{"location":"notes/Harvard_CS50/0x06_Python/#31-pyttsx3-library","text":"On our own Mac or PC, we can open a terminal after installing Python, and use another library to convert text to speech: 1 2 3 4 5 import pyttsx3 engine = pyttsx3 . init () engine . say ( \"hello, world\" ) engine . runAndWait () By reading the documentation, we can figure out how to initialize the library, and say a string. We can even pass in a format string with engine.say(f\"hello, {name}\") to say some input.","title":"3.1. pyttsx3 library"},{"location":"notes/Harvard_CS50/0x06_Python/#32-face_recognition","text":"We can use another library, face_recognition , to find faces in images: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # Find faces in picture # https://github.com/ageitgey/face_recognition/blob/master/examples/find_faces_in_picture.py from PIL import Image import face_recognition # Load the jpg file into a numpy array image = face_recognition . load_image_file ( \"office.jpg\" ) # Find all the faces in the image using the default HOG-based model. # This method is fairly accurate, but not as accurate as the CNN model and not GPU accelerated. # See also: find_faces_in_picture_cnn.py face_locations = face_recognition . face_locations ( image ) for face_location in face_locations : # Print the location of each face in this image top , right , bottom , left = face_location # You can access the actual face itself like this: face_image = image [ top : bottom , left : right ] pil_image = Image . fromarray ( face_image ) pil_image . show () With recognize.py , we can write a program that finds a match for a particular face.","title":"3.2. face_recognition"},{"location":"notes/Harvard_CS50/0x06_Python/#33-qrcode","text":"We can create a QR code, or two-dimensional barcode, with another library: 1 2 3 4 5 6 import os import qrcode img = qrcode . make ( \"https://youtu.be/oHg5SJYRHA0\" ) img . save ( \"qr.png\" , \"PNG\" ) os . system ( \"open qr.png\" )","title":"3.3. qrcode"},{"location":"notes/Harvard_CS50/0x06_Python/#34-speech_recognition","text":"We can recognize audio input from a microphone: 1 2 3 4 5 6 7 8 9 10 11 import speech_recognition # Obtain audio from the microphone recognizer = speech_recognition . Recognizer () with speech_recognition . Microphone () as source : print ( \"Say something:\" ) audio = recognizer . listen ( source ) # Recognize speech using Google Speech Recognition print ( \"You said:\" ) print ( recognizer . recognize_google ( audio )) We\u2019re following the documentation of the library to listen to our microphone and convert it to text. 1 2 3 4 5 6 7 8 9 10 11 12 ... words = recognizer . recognize_google ( audio ) # Respond to speech if \"hello\" in words : print ( \"Hello to you too!\" ) elif \"how are you\" in words : print ( \"I am well, thanks!\" ) elif \"goodbye\" in words : print ( \"Goodbye to you too!\" ) else : print ( \"Huh?\" ) Finally, we use another, more sophisticated program to generate deepfakes, or realistic-appearing but computer-generated videos of various personalities. By taking advantage of all these libraries that are freely available online, we can easily add advanced functionality to our own applications.","title":"3.4. speech_recognition"},{"location":"notes/Harvard_CS50/0x07_SQL/","text":"1. Data processing 1.1. About Data processing 1.1.1. Spreadsheet applications Suppose we'll collect some data about your favorite TV shows and their genres. With hundreds of responses, we can start looking at the responses on Google Sheets, a web-based spreadsheet application, showing our data in rows and columns. Notice that some responses show a single genre selected, like \"Comedy\", while others, with multiple genres, show them in one cell but separated by a comma, like \"Crime, Drama\" . With a spreadsheet application like Google sheets, Apple's Number, Microsoft Excel, or others, we can: Sort our data Store our data in rows and columns, where each additional entry is a row, and properties of each entry, like title or genre, is a column Decide on the schema , or format of our data in advance by choosing the columns. 1.1.2. Databases A database is a file or program that stores data for us. A CSV (Comma-Separated Values) file is a flat-file database where the data for each column is separated by commas, and each row is on a new line, saved simple as a file. If some data in a CSV file contains a comma itself, then it's usually surrounded by quotes as a string to prevent confusion. Formulas and calculations in spreadsheet programs are built into the programs themselves; a CSV file can only store raw, static values. 1.2. Cleaning First, we've import our CSV file to the IDE, and we can take a look at all the unique titles in our responses using Python. 1 2 3 4 5 6 7 8 9 10 11 12 import csv titles = set () with open ( \"Favorite TV Shows - Form Responses 1.csv\" , \"r\" ) as file : reader = csv . DictReader ( file ) for row in reader : titles . add ( row [ \"title\" ]) for title in titles : print ( title ) We used DictReader in csv library, dictionary reader, which creates a dictionary from each row, allowing us to access each column by its name (Since the first row in our CSV has the names of the columns, which can be used to label each column in our data as well). Therefore we also don't need to skip the header row in this case. We create titles as a set , which will automatically check for duplicates and ensure there are only unique values. To sort the titles, we can just change our loop to for title in sorted(titles) , which will sort our set before we iterate over it. But we'll see that our titles are considered different if their capitalization or punctuation is different, like \"friends\", \"Friends\" and \"Friends \" (this one has spaces at the end). So we'll clean up the capitalization by adding title in all uppercase with titles.add(row[\"title\"].upper()) . We'll also have to remove spaces before or after, so we can add titles.add(row[\"title\"].strip().upper()) which strips the whitespace from the title, and then converts it to uppercase. Now we've canonicalized , or standardized, our data, and our list of titles are much cleaner. 1.3. Counting We can use a dictionary, instead of a set, to count the number of times we've seen each title, with the keys being the titles and the values being an integer counting the number of times we see each of them: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import csv titles = {} with open ( \"Favorite TV Shows - Form Responses 1.csv\" , \"r\" ) as file : reader = csv . DictReader ( file ) for row in reader : title = row [ \"title\" ] . strip () . upper () if title not in titles : titles [ title ] = 0 titles [ title ] += 1 for title in sorted ( titles ): print ( title , titles [ title ]) Here, we first check if we\u2019ve haven\u2019t seen the title before (if it\u2019s not in titles ). We set the initial value to 0 if that\u2019s the case, and then we can safely increment the value by 1 every time. Finally, we can print out our dictionary\u2019s keys and values by passing them as arguments to print , which will separate them by a space for us. We can sort by the values in the dictionary by changing our loop to: 1 2 3 4 5 6 ... def f ( title ): return titles [ title ] for title in sorted ( titles , key = f , reverse = True ): ... We define a function, f , which just returns the count of a title in the dictionary with titles[title] . The sorted function, in turn, will use that function as the key to sort the dictionary's elements. And we also pass in reverse=True to sort from largest to smallest, instead of smallest to largest. We can actually define our function in the same line, with this syntax: 1 for title in sorted ( titles , key = lambda title : titles [ title ], reverse = True ): We pass in a lambda , or anonymous function, which has no name but takes in some argument or arguments, and returns a value immediately. 1.4. Searching We can write a program to search for a title and report its popularity: 1 2 3 4 5 6 7 8 9 10 11 12 13 import csv title = input ( \"Title: \" ) . strip () . upper () with open ( \"Favorite TV Shows - Form Responses 1.csv\" , \"r\" ) as file : reader = csv . DictReader ( file ) counter = 0 for row in reader : if row [ \"title\" ] . strip () . upper () == title : counter += 1 print ( counter ) We ask the user for input, and then open our CSV file. Since we\u2019re looking for just one title, we can have one counter variable that we increment. We check for matches after standardizing both the input and the data as we check each row. The running time of this is O ( n ), since we need to look at every row. 2. Relational databases 2.1. What is Relational databases and SQLite Relational databases are programs that store data, ultimately in files, but with additional data structures that allow us to search and store data more efficiently. With another programming language, SQL (pronounced like \"sequel\"), Structure Query Language, we can interact with many relational databases and their tables , like spreadsheets, which store data. We'll use a common database called SQLite , one of many available programs that support SQL. Other databases programs include Oracle Database, MySQL, PostgreSQL, and Microsoft Access. SQLite stores our data in binary file , with 0s and 1s that represent data efficiently. We'll interact with our tables of data through a command-line program, sqlite3 . We'll run some commands to import our CSV file into a table called \"shows\". 1 2 3 4 5 6 7 ~/ $ sqlite3 SQLite version 3.32.3 2020-06-18 14:16:19 Enter \".help\" for usage hints. Connected to a transient in-memory database. Use \".open FILENAME\" to reopen on a persistent database. sqlite> .mode csv sqlite> .import 'Favorite TV Shows (Responses) - Form Responses 1.csv' shows Based on the rows in the CSV file, SQLite will create a table in our database with the data and columns. We\u2019ll set SQLite to CSV mode, and use the .import command to create a table from our file. It turns out that, when working with data, we generally need four types of operations supported by relational databases: CRUD , which is the abbreviation for: CREATE READ / RETRIEVE UPDATE DELETE 2.2. SQL 2.2.1. CRUD In SQL, the commands to perform each of these operations are: CREATE, INSERT E.g., to create a new table, we can use: CREATE table (column type, ...); where table is the name of our new table, and column is the name of a column, followed by its type. SELECT SELECT column FROM table; UPDATE DELETE We can check the schema of our new table with .schema : 1 2 3 4 5 6 sqlite> .schema CREATE TABLE shows( \"Timestamp\" TEXT, \"title\" TEXT, \"genres\" TEXT ); We see that .import used the CREATE TABLE ... command listed to create a table called shows , with column names automatically copied from the CSV's header row and types assumed to be text. We can select a column with: 1 2 3 4 5 6 sqlite> SELECT title FROM shows; title ... \"Madam Secretary\" \"Game of Thrones\" \"Still Game\" Notice that we capitalize SQL keywords by convention, and we'll see titles from our rows printed in the order from the CSV. We can also select multiple columns with SELECT Timestamp, title FROM shows; , or all columns with SELECT * FROM shows; , where * is a wild card means all in SQL. 2.2.2. Functions SQL supports many functions that we can use to count and summarize data: AVG COUNT DISTINCT , for getting distinct values without duplicates LOWER MAX MIN UPPER ... We can clean up our titles as before, converting them to uppercase and printing only the unique value: 1 2 3 4 5 6 sqlite> SELECT DISTINCT(UPPER(title)) FROM shows; title ... \"GREY'S ANATOMY\" \"SCOOBY DOO\" \"MADAM SECRETARY\" 2.2.3. Clauses We can also add more clauses , or phrases that modify our query: WHERE , matching results on a strict condition LIKE , matching results on a less strict condition ORDER BY , ordering results in some way LIMIT , limiting the number of results GROUP BY , grouping results in some way ... We can filter rows by titles: 1 2 3 4 5 6 sqlite> SELECT title FROM shows WHERE title = \"The Office\"; title ... \"The Office\" \"The Office\" \"The Office\" But there are other entries we would like to catch, so we can use: 1 2 3 4 5 6 7 sqlite> SELECT title FROM shows WHERE title LIKE \"%Office%\"; title ... office \"The Office\" \"the office \" \"The Office\" The % character is a placeholder for zero or more other characters. We can even group the same titles together, and count the number of times they appear: 1 2 3 4 5 6 7 8 sqlite> SELECT UPPER(title), COUNT(title) FROM shows GROUP BY UPPER(title); ... \"THE OFFICE\",23 ... \"TOP GEAR\",1 ... \"TWIN PEAKS\",4 ... We can order by the counts: 1 2 3 4 5 sqlite> SELECT UPPER(title), COUNT(title) FROM shows GROUP BY UPPER(title) ORDER BY COUNT(title); ... \"THE OFFICE\",23 FRIENDS,26 \"GAME OF THRONES\",33 And if we add DESC to the end, we could see the results in descending order. With LIMIT 10 added as well, we see the top 10 rows: 1 2 3 4 5 6 sqlite> SELECT UPPER(title), COUNT(title) FROM shows GROUP BY UPPER(title) ORDER BY COUNT(title) DESC LIMIT 10; UPPER(title),COUNT(title) \"GAME OF THRONES\",33 FRIENDS,26 \"THE OFFICE\",23 ... Finally, we\u2019ll trim whitespace from each title too, nesting that function: 1 2 3 4 5 6 sqlite> SELECT UPPER(TRIM(title)), COUNT(title) FROM shows GROUP BY UPPER(TRIM(title)) ORDER BY COUNT(title) DESC LIMIT 10; UPPER(title),COUNT(title) \"GAME OF THRONES\",33 \"FRIENDS\",26 \"THE OFFICE\",23 ... 2.2.4. Saving data Before we finish, we\u2019ll want to save our data into a file with .save shows.db , which we\u2019ll see in our IDE after running that command. Notice that our program to find the most popular shows from earlier, which took dozens of lines of code in Python, now only requires one (long) line of SQL. We\u2019ve used SQLite\u2019s command-line interface, but there are also graphical programs that support working with SQL queries and viewing results more visually. 2.3. Tables 2.3.1. CRUD in a table Our genres column has multiple genres in the same field, so we'll use LIKE to get all the titles containing some genres: 1 2 sqlite> SELECT title FROM shows WHERE genres LIKE \"%Comedy%\"; ... But the genres are still stored in comma-separated list themselves, which is not as clean. E.g., if our genres included both \u201cMusic\u201d and \u201cMusical\u201d, it would be difficult to select titles with just the \u201cMusic\u201d genre. We can insert data into a table manually with INSERT INTO table (column, ...) VALUES(value, ...); . For example, we can say: 1 sqlite> INSERT INTO shows (Timestamp, title, genres) VALUES(\"now\", \"The Muppet Show\", \"Comedy, Musical\"); We can update a row with UPDATE table SET column = value WHERE condition; , like: 1 sqlite> UPDATE shows SET genres = \"Comedy, Drama, Musical\" WHERE title = \"The Muppet Show\"; We can even remove all rows that match with: DELETE FROM table WHERE condition; : 1 sqlite> DELETE FROM shows WHERE title LIKE \"Friends\"; 2.3.2. Design tables Now let\u2019s write our own Python program that will use SQL to import our CSV data into tables with the following design: This design will start to normalize our data, or reduce redundancy and ensure a single source of truth. Here, for example, we have a table named shows , with each show having an id and title , and another table, genre , which uses each\u2019s show\u2019s id to associate a genre with a show. Note that the show\u2019s title doesn\u2019t need to be stored multiple times. We can also now add multiple rows in the genre table, to associate a show with more than one genre. 2.3.3. Columns' data types in SQL It turns out that SQL, too, has its own data types to optimize the amount of space used for storing data, which we\u2019ll need to specify when creating a table manually: BLOB , for \"binary large object\", raw binary data that might represents files INTEGER NUMERIC , number-like but not quite a number, like a data or time REAL , for floating-point values TEXT , like strings 2.3.4. Columns' Attributes in SQL Columns can also have additional attributes: NOT NULL , which specifies that there must be some values UNIQUE , which means that the value for that column must be unique for every row in that table PRIMARY KEY , like the id column above that will used to uniquely identify each row FOREIGN KEY , like the show_id column above that refers to a column in some other table 2.3.5. SQL in Python We\u2019ll use the CS50 library\u2019s SQL feature to make queries easily, and there are other libraries for Python as well: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import csv from cs50 import SQL open ( \"shows.db\" , \"w\" ) . close () db = SQL ( \"sqlite:///shows.db\" ) db . execute ( \"CREATE TABLE shows (id INTEGER, title TEXT, PRIMARY KEY(id))\" ) db . execute ( \"CREATE TABLE genres (show_id INTEGER, genre TEXT, FOREIGN KEY(show_id) REFERENCES shows(id))\" ) with open ( \"Favorite TV Shows - Form Responses 1.csv\" , \"r\" ) as file : reader = csv . DictReader ( file ) for row in reader : title = row [ \"title\" ] . strip () . upper () id = db . execute ( \"INSERT INTO shows (title) VALUES(?)\" , title ) for genre in row [ \"genres\" ] . split ( \", \" ): db . execute ( \"INSERT INTO genres (show_id, genre) VALUES(?, ?)\" , id , genre ) First, we\u2019ll open a shows.db file and close it, to make sure that the file is created. Then, we\u2019ll create a db variable to store our database created by SQL , which takes the database file we just created. Next, we\u2019ll run SQL commands by writing it as a string, and calling db.execute with it. Here, we\u2019ll create two tables as we designed above, indicating the names, types, and properties of each column we want in each table. Now, we can read our original CSV file row by row, getting the title and using db.execute to run an INSERT command for each row. It turns out that we can use the ? placeholder in a SQL command, and pass in a variable to be substituted. Then, we\u2019ll get back an id that\u2019s automatically created for us for each row, since we declared it to be a primary key. Finally, we\u2019ll split the genre string in each row by the comma, and insert each of them into the genres table, using the id for the show as show_id . After we run this program, we can see the IDs and titles of each show, as well as the genres where the first column is a show\u2019s ID: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 sqlite> SELECT * FROM shows; ... 511 | MADAM SECRETARY 512 | GAME OF THRONES 513 | STILL GAME sqlite> SELECT * FROM genres; ... 511 | Drama 512 | Action 512 | Adventure 512 | History 512 | Thriller 512 | War 513 | Comedy Notice that the show with id 512, \u201cGAME OF THRONES\u201d, now has five genres associated with it. 2.3.6. Nested query To find all the musicals, for example, we can run: 1 2 3 4 5 sqlite> SELECT show_id FROM genres WHERE genre = \"Musical\"; ... 422 435 468 And we can nest that query to get titles from the list of show IDs: 1 2 3 4 5 6 sqlite> SELECT title FROM shows WHERE id IN (SELECT show_id FROM genres WHERE genre = \"Musical\"); title BREAKING BAD ... THE LAWYER MY BROTHER, MY BROTHER, AND ME Our first query, in the parentheses, will be executed first, and then used in the outer query. We can find all the rows in shows with the title of \u201cTHE OFFICE\u201d, and find all the genres associated: 1 2 3 4 5 6 sqlite> SELECT DISTINCT(genre) FROM genres WHERE show_id IN (SELECT id FROM shows WHERE title = \"THE OFFICE\") ORDER BY genre; genre ... Comedy Documentary ... We could improve on the design of our tables even more, with a third table: Now, each genre\u2019s name will only be stored once, with a new table, a join table , called shows_genres that contains foreign keys that link shows to genres. This is a many-to-many relationship, where one show can have many genres, and one genre can belong to many shows. If we needed to change a genre\u2019s name, we would only have to change one row now, instead of many. 2.3.7. Subtypes It turns out that there are subtypes for a column, too, that we can be even more specific with: INTEGER smallint , with fewer bits integer bigint , with more bits NUMERIC boolean data datatime numeric(scale, precision) , with a fixed number of digits time timestamp REAL real double precision , with twice as many bits TEXT char(n) , a fixed number of characters varchar(n) , a variable number text , a string with no limit 3. Indexes and JOIN 3.1. What is IMDb IMDb, abbreviation for the Internet Movie Database, has datasets available for download as TSV (table-separated values) file. 3.2. Schema of IMDb After we import one such dataset, we'll see tables with the following schemas: The genres table has some duplication, since the genre column is repeated, but the stars and writers table join rows in the people and shows table based on their relationship. 3.3. indexes With SELECT COUNT(*) FROM shows; we can see that there are more than 150,000 shows in our table, so with a large amount of data we can use indexes , which tells our database program to create additional data structures so we can search and sort with logarithmic time : 1 sqlite> CREATE INDEX title_index on shows(title); It turns out that these data structures are generally B-trees , like binary trees we've seen in C, with nodes organized such that we search faster than linearly. Creating an index takes some time, but afterwards we can run queries much more quickly. 3.4. Join With our data spread among different tables, we can use JOIN commands to combine them in our queries: 1 2 3 4 5 6 7 sqlite3> SELECT title FROM people ...> JOIN stars ON people.id = stars.person_id ...> JOIN shows ON stars.show_id = shows.id ...> WHERE name = \"Steve Carell\"; ... The Morning Show LA Times: the Envelope With the JOIN syntax, we can virtually combine tables based on their foreign keys, and use their columns as though they were one table. 4. Problems 4.1. SQL injection attack One problem in SQL is called a SQL injection attack , where someone can inject , or place, their own commands into inputs that we then run on our database. Our query for logging a user in might be rows = db.execute(\"SELECT * FROM users WHERE username = ? AND password = ?\", username, password) . By using the ? placeholders, our SQL library will escape the input, or prevent dangerous characters from being interpreted as part of the command. In contrast, we might have a SQL query that\u2019s a formatted string, such as: 1 f \"SELECT * FROM users WHERE username = ' { username } ' AND password = ' { password } '\" If a user types in malan@harvard.edu'-- , then the query will end up being: 1 f \"SELECT * FROM users WHERE username = 'malan@harvard.edu'--' AND password = ' { password } '\" This query will actually select the row where username = 'malan@harvard.edu' , without checking the password, since the -- turns the rest of the line into a comment in SQL. 4.2. Race conditions Another problem with databases is race conditions , where code in a multi-threaded environment can be commingled, or mixed together, in each thread. One example is a popular post getting lots of likes. A server might try to increment the number of likes, asking the database for the current number of likes, adding one, and updating the value in the database: 1 2 3 row = db . execute ( \"SELECT likes FROM posts WHERE id = ?\" , id ) likes = row [ 0 ][ \"likes\" ] db . execute ( \"UPDATE posts SET likes = ? WHERE id = ?\" , likes + 1 , id ) But for applications with multiple servers, each of them might trying to add likes at the same time. Two servers, responding to two different users, might get the same starting number of likes since the first line of code runs at the same time on each server. Then, both will set the same new number of likes, even though there should have been two separate increments. To solve this problem, SQL supports transactions , where we can look rows in a database, such that a particular set of actions are guaranteed to happen together, with syntax like: BEGIN TRANSACTION COMMIT ROLLBACK E.g., we can fix our problem above with: 1 2 3 4 5 db . execute ( \"BEGIN TRANSACTION\" ) rows = db . execute ( \"SELECT likes FROM posts WHERE id = ?;\" , id ) likes = rows [ 0 ][ \"likes\" ] db . execute ( \"UPDATE posts SET likes = ? WHERE id = ?;\" , likes + 1 , id ) db . execute ( \"COMMIT\" ) The database will ensure that all the query in between are executed together. Another example might be of two roommates and a shared fridge in their dorm. The first roommate comes home, and sees that there is no milk in the fridge. So the first roommate leaves to the store to buy milk, and while they are at the store, the second roommate comes home, sees that there is no milk, and leaves for another store to get milk as well. Later, there will be two jugs of milk in the fridge. We can solve this problem by locking the fridge so that our roommate can\u2019t check whether there is milk until we\u2019ve gotten back.","title":"Lec 07: SQL"},{"location":"notes/Harvard_CS50/0x07_SQL/#1-data-processing","text":"","title":"1. Data processing"},{"location":"notes/Harvard_CS50/0x07_SQL/#11-about-data-processing","text":"","title":"1.1. About Data processing"},{"location":"notes/Harvard_CS50/0x07_SQL/#111-spreadsheet-applications","text":"Suppose we'll collect some data about your favorite TV shows and their genres. With hundreds of responses, we can start looking at the responses on Google Sheets, a web-based spreadsheet application, showing our data in rows and columns. Notice that some responses show a single genre selected, like \"Comedy\", while others, with multiple genres, show them in one cell but separated by a comma, like \"Crime, Drama\" . With a spreadsheet application like Google sheets, Apple's Number, Microsoft Excel, or others, we can: Sort our data Store our data in rows and columns, where each additional entry is a row, and properties of each entry, like title or genre, is a column Decide on the schema , or format of our data in advance by choosing the columns.","title":"1.1.1. Spreadsheet applications"},{"location":"notes/Harvard_CS50/0x07_SQL/#112-databases","text":"A database is a file or program that stores data for us. A CSV (Comma-Separated Values) file is a flat-file database where the data for each column is separated by commas, and each row is on a new line, saved simple as a file. If some data in a CSV file contains a comma itself, then it's usually surrounded by quotes as a string to prevent confusion. Formulas and calculations in spreadsheet programs are built into the programs themselves; a CSV file can only store raw, static values.","title":"1.1.2. Databases"},{"location":"notes/Harvard_CS50/0x07_SQL/#12-cleaning","text":"First, we've import our CSV file to the IDE, and we can take a look at all the unique titles in our responses using Python. 1 2 3 4 5 6 7 8 9 10 11 12 import csv titles = set () with open ( \"Favorite TV Shows - Form Responses 1.csv\" , \"r\" ) as file : reader = csv . DictReader ( file ) for row in reader : titles . add ( row [ \"title\" ]) for title in titles : print ( title ) We used DictReader in csv library, dictionary reader, which creates a dictionary from each row, allowing us to access each column by its name (Since the first row in our CSV has the names of the columns, which can be used to label each column in our data as well). Therefore we also don't need to skip the header row in this case. We create titles as a set , which will automatically check for duplicates and ensure there are only unique values. To sort the titles, we can just change our loop to for title in sorted(titles) , which will sort our set before we iterate over it. But we'll see that our titles are considered different if their capitalization or punctuation is different, like \"friends\", \"Friends\" and \"Friends \" (this one has spaces at the end). So we'll clean up the capitalization by adding title in all uppercase with titles.add(row[\"title\"].upper()) . We'll also have to remove spaces before or after, so we can add titles.add(row[\"title\"].strip().upper()) which strips the whitespace from the title, and then converts it to uppercase. Now we've canonicalized , or standardized, our data, and our list of titles are much cleaner.","title":"1.2. Cleaning"},{"location":"notes/Harvard_CS50/0x07_SQL/#13-counting","text":"We can use a dictionary, instead of a set, to count the number of times we've seen each title, with the keys being the titles and the values being an integer counting the number of times we see each of them: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import csv titles = {} with open ( \"Favorite TV Shows - Form Responses 1.csv\" , \"r\" ) as file : reader = csv . DictReader ( file ) for row in reader : title = row [ \"title\" ] . strip () . upper () if title not in titles : titles [ title ] = 0 titles [ title ] += 1 for title in sorted ( titles ): print ( title , titles [ title ]) Here, we first check if we\u2019ve haven\u2019t seen the title before (if it\u2019s not in titles ). We set the initial value to 0 if that\u2019s the case, and then we can safely increment the value by 1 every time. Finally, we can print out our dictionary\u2019s keys and values by passing them as arguments to print , which will separate them by a space for us. We can sort by the values in the dictionary by changing our loop to: 1 2 3 4 5 6 ... def f ( title ): return titles [ title ] for title in sorted ( titles , key = f , reverse = True ): ... We define a function, f , which just returns the count of a title in the dictionary with titles[title] . The sorted function, in turn, will use that function as the key to sort the dictionary's elements. And we also pass in reverse=True to sort from largest to smallest, instead of smallest to largest. We can actually define our function in the same line, with this syntax: 1 for title in sorted ( titles , key = lambda title : titles [ title ], reverse = True ): We pass in a lambda , or anonymous function, which has no name but takes in some argument or arguments, and returns a value immediately.","title":"1.3. Counting"},{"location":"notes/Harvard_CS50/0x07_SQL/#14-searching","text":"We can write a program to search for a title and report its popularity: 1 2 3 4 5 6 7 8 9 10 11 12 13 import csv title = input ( \"Title: \" ) . strip () . upper () with open ( \"Favorite TV Shows - Form Responses 1.csv\" , \"r\" ) as file : reader = csv . DictReader ( file ) counter = 0 for row in reader : if row [ \"title\" ] . strip () . upper () == title : counter += 1 print ( counter ) We ask the user for input, and then open our CSV file. Since we\u2019re looking for just one title, we can have one counter variable that we increment. We check for matches after standardizing both the input and the data as we check each row. The running time of this is O ( n ), since we need to look at every row.","title":"1.4. Searching"},{"location":"notes/Harvard_CS50/0x07_SQL/#2-relational-databases","text":"","title":"2. Relational databases"},{"location":"notes/Harvard_CS50/0x07_SQL/#21-what-is-relational-databases-and-sqlite","text":"Relational databases are programs that store data, ultimately in files, but with additional data structures that allow us to search and store data more efficiently. With another programming language, SQL (pronounced like \"sequel\"), Structure Query Language, we can interact with many relational databases and their tables , like spreadsheets, which store data. We'll use a common database called SQLite , one of many available programs that support SQL. Other databases programs include Oracle Database, MySQL, PostgreSQL, and Microsoft Access. SQLite stores our data in binary file , with 0s and 1s that represent data efficiently. We'll interact with our tables of data through a command-line program, sqlite3 . We'll run some commands to import our CSV file into a table called \"shows\". 1 2 3 4 5 6 7 ~/ $ sqlite3 SQLite version 3.32.3 2020-06-18 14:16:19 Enter \".help\" for usage hints. Connected to a transient in-memory database. Use \".open FILENAME\" to reopen on a persistent database. sqlite> .mode csv sqlite> .import 'Favorite TV Shows (Responses) - Form Responses 1.csv' shows Based on the rows in the CSV file, SQLite will create a table in our database with the data and columns. We\u2019ll set SQLite to CSV mode, and use the .import command to create a table from our file. It turns out that, when working with data, we generally need four types of operations supported by relational databases: CRUD , which is the abbreviation for: CREATE READ / RETRIEVE UPDATE DELETE","title":"2.1. What is Relational databases and SQLite"},{"location":"notes/Harvard_CS50/0x07_SQL/#22-sql","text":"","title":"2.2. SQL"},{"location":"notes/Harvard_CS50/0x07_SQL/#221-crud","text":"In SQL, the commands to perform each of these operations are: CREATE, INSERT E.g., to create a new table, we can use: CREATE table (column type, ...); where table is the name of our new table, and column is the name of a column, followed by its type. SELECT SELECT column FROM table; UPDATE DELETE We can check the schema of our new table with .schema : 1 2 3 4 5 6 sqlite> .schema CREATE TABLE shows( \"Timestamp\" TEXT, \"title\" TEXT, \"genres\" TEXT ); We see that .import used the CREATE TABLE ... command listed to create a table called shows , with column names automatically copied from the CSV's header row and types assumed to be text. We can select a column with: 1 2 3 4 5 6 sqlite> SELECT title FROM shows; title ... \"Madam Secretary\" \"Game of Thrones\" \"Still Game\" Notice that we capitalize SQL keywords by convention, and we'll see titles from our rows printed in the order from the CSV. We can also select multiple columns with SELECT Timestamp, title FROM shows; , or all columns with SELECT * FROM shows; , where * is a wild card means all in SQL.","title":"2.2.1. CRUD"},{"location":"notes/Harvard_CS50/0x07_SQL/#222-functions","text":"SQL supports many functions that we can use to count and summarize data: AVG COUNT DISTINCT , for getting distinct values without duplicates LOWER MAX MIN UPPER ... We can clean up our titles as before, converting them to uppercase and printing only the unique value: 1 2 3 4 5 6 sqlite> SELECT DISTINCT(UPPER(title)) FROM shows; title ... \"GREY'S ANATOMY\" \"SCOOBY DOO\" \"MADAM SECRETARY\"","title":"2.2.2. Functions"},{"location":"notes/Harvard_CS50/0x07_SQL/#223-clauses","text":"We can also add more clauses , or phrases that modify our query: WHERE , matching results on a strict condition LIKE , matching results on a less strict condition ORDER BY , ordering results in some way LIMIT , limiting the number of results GROUP BY , grouping results in some way ... We can filter rows by titles: 1 2 3 4 5 6 sqlite> SELECT title FROM shows WHERE title = \"The Office\"; title ... \"The Office\" \"The Office\" \"The Office\" But there are other entries we would like to catch, so we can use: 1 2 3 4 5 6 7 sqlite> SELECT title FROM shows WHERE title LIKE \"%Office%\"; title ... office \"The Office\" \"the office \" \"The Office\" The % character is a placeholder for zero or more other characters. We can even group the same titles together, and count the number of times they appear: 1 2 3 4 5 6 7 8 sqlite> SELECT UPPER(title), COUNT(title) FROM shows GROUP BY UPPER(title); ... \"THE OFFICE\",23 ... \"TOP GEAR\",1 ... \"TWIN PEAKS\",4 ... We can order by the counts: 1 2 3 4 5 sqlite> SELECT UPPER(title), COUNT(title) FROM shows GROUP BY UPPER(title) ORDER BY COUNT(title); ... \"THE OFFICE\",23 FRIENDS,26 \"GAME OF THRONES\",33 And if we add DESC to the end, we could see the results in descending order. With LIMIT 10 added as well, we see the top 10 rows: 1 2 3 4 5 6 sqlite> SELECT UPPER(title), COUNT(title) FROM shows GROUP BY UPPER(title) ORDER BY COUNT(title) DESC LIMIT 10; UPPER(title),COUNT(title) \"GAME OF THRONES\",33 FRIENDS,26 \"THE OFFICE\",23 ... Finally, we\u2019ll trim whitespace from each title too, nesting that function: 1 2 3 4 5 6 sqlite> SELECT UPPER(TRIM(title)), COUNT(title) FROM shows GROUP BY UPPER(TRIM(title)) ORDER BY COUNT(title) DESC LIMIT 10; UPPER(title),COUNT(title) \"GAME OF THRONES\",33 \"FRIENDS\",26 \"THE OFFICE\",23 ...","title":"2.2.3. Clauses"},{"location":"notes/Harvard_CS50/0x07_SQL/#224-saving-data","text":"Before we finish, we\u2019ll want to save our data into a file with .save shows.db , which we\u2019ll see in our IDE after running that command. Notice that our program to find the most popular shows from earlier, which took dozens of lines of code in Python, now only requires one (long) line of SQL. We\u2019ve used SQLite\u2019s command-line interface, but there are also graphical programs that support working with SQL queries and viewing results more visually.","title":"2.2.4. Saving data"},{"location":"notes/Harvard_CS50/0x07_SQL/#23-tables","text":"","title":"2.3. Tables"},{"location":"notes/Harvard_CS50/0x07_SQL/#231-crud-in-a-table","text":"Our genres column has multiple genres in the same field, so we'll use LIKE to get all the titles containing some genres: 1 2 sqlite> SELECT title FROM shows WHERE genres LIKE \"%Comedy%\"; ... But the genres are still stored in comma-separated list themselves, which is not as clean. E.g., if our genres included both \u201cMusic\u201d and \u201cMusical\u201d, it would be difficult to select titles with just the \u201cMusic\u201d genre. We can insert data into a table manually with INSERT INTO table (column, ...) VALUES(value, ...); . For example, we can say: 1 sqlite> INSERT INTO shows (Timestamp, title, genres) VALUES(\"now\", \"The Muppet Show\", \"Comedy, Musical\"); We can update a row with UPDATE table SET column = value WHERE condition; , like: 1 sqlite> UPDATE shows SET genres = \"Comedy, Drama, Musical\" WHERE title = \"The Muppet Show\"; We can even remove all rows that match with: DELETE FROM table WHERE condition; : 1 sqlite> DELETE FROM shows WHERE title LIKE \"Friends\";","title":"2.3.1. CRUD in a table"},{"location":"notes/Harvard_CS50/0x07_SQL/#232-design-tables","text":"Now let\u2019s write our own Python program that will use SQL to import our CSV data into tables with the following design: This design will start to normalize our data, or reduce redundancy and ensure a single source of truth. Here, for example, we have a table named shows , with each show having an id and title , and another table, genre , which uses each\u2019s show\u2019s id to associate a genre with a show. Note that the show\u2019s title doesn\u2019t need to be stored multiple times. We can also now add multiple rows in the genre table, to associate a show with more than one genre.","title":"2.3.2. Design tables"},{"location":"notes/Harvard_CS50/0x07_SQL/#233-columns-data-types-in-sql","text":"It turns out that SQL, too, has its own data types to optimize the amount of space used for storing data, which we\u2019ll need to specify when creating a table manually: BLOB , for \"binary large object\", raw binary data that might represents files INTEGER NUMERIC , number-like but not quite a number, like a data or time REAL , for floating-point values TEXT , like strings","title":"2.3.3. Columns' data types in SQL"},{"location":"notes/Harvard_CS50/0x07_SQL/#234-columns-attributes-in-sql","text":"Columns can also have additional attributes: NOT NULL , which specifies that there must be some values UNIQUE , which means that the value for that column must be unique for every row in that table PRIMARY KEY , like the id column above that will used to uniquely identify each row FOREIGN KEY , like the show_id column above that refers to a column in some other table","title":"2.3.4. Columns' Attributes in SQL"},{"location":"notes/Harvard_CS50/0x07_SQL/#235-sql-in-python","text":"We\u2019ll use the CS50 library\u2019s SQL feature to make queries easily, and there are other libraries for Python as well: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import csv from cs50 import SQL open ( \"shows.db\" , \"w\" ) . close () db = SQL ( \"sqlite:///shows.db\" ) db . execute ( \"CREATE TABLE shows (id INTEGER, title TEXT, PRIMARY KEY(id))\" ) db . execute ( \"CREATE TABLE genres (show_id INTEGER, genre TEXT, FOREIGN KEY(show_id) REFERENCES shows(id))\" ) with open ( \"Favorite TV Shows - Form Responses 1.csv\" , \"r\" ) as file : reader = csv . DictReader ( file ) for row in reader : title = row [ \"title\" ] . strip () . upper () id = db . execute ( \"INSERT INTO shows (title) VALUES(?)\" , title ) for genre in row [ \"genres\" ] . split ( \", \" ): db . execute ( \"INSERT INTO genres (show_id, genre) VALUES(?, ?)\" , id , genre ) First, we\u2019ll open a shows.db file and close it, to make sure that the file is created. Then, we\u2019ll create a db variable to store our database created by SQL , which takes the database file we just created. Next, we\u2019ll run SQL commands by writing it as a string, and calling db.execute with it. Here, we\u2019ll create two tables as we designed above, indicating the names, types, and properties of each column we want in each table. Now, we can read our original CSV file row by row, getting the title and using db.execute to run an INSERT command for each row. It turns out that we can use the ? placeholder in a SQL command, and pass in a variable to be substituted. Then, we\u2019ll get back an id that\u2019s automatically created for us for each row, since we declared it to be a primary key. Finally, we\u2019ll split the genre string in each row by the comma, and insert each of them into the genres table, using the id for the show as show_id . After we run this program, we can see the IDs and titles of each show, as well as the genres where the first column is a show\u2019s ID: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 sqlite> SELECT * FROM shows; ... 511 | MADAM SECRETARY 512 | GAME OF THRONES 513 | STILL GAME sqlite> SELECT * FROM genres; ... 511 | Drama 512 | Action 512 | Adventure 512 | History 512 | Thriller 512 | War 513 | Comedy Notice that the show with id 512, \u201cGAME OF THRONES\u201d, now has five genres associated with it.","title":"2.3.5. SQL in Python"},{"location":"notes/Harvard_CS50/0x07_SQL/#236-nested-query","text":"To find all the musicals, for example, we can run: 1 2 3 4 5 sqlite> SELECT show_id FROM genres WHERE genre = \"Musical\"; ... 422 435 468 And we can nest that query to get titles from the list of show IDs: 1 2 3 4 5 6 sqlite> SELECT title FROM shows WHERE id IN (SELECT show_id FROM genres WHERE genre = \"Musical\"); title BREAKING BAD ... THE LAWYER MY BROTHER, MY BROTHER, AND ME Our first query, in the parentheses, will be executed first, and then used in the outer query. We can find all the rows in shows with the title of \u201cTHE OFFICE\u201d, and find all the genres associated: 1 2 3 4 5 6 sqlite> SELECT DISTINCT(genre) FROM genres WHERE show_id IN (SELECT id FROM shows WHERE title = \"THE OFFICE\") ORDER BY genre; genre ... Comedy Documentary ... We could improve on the design of our tables even more, with a third table: Now, each genre\u2019s name will only be stored once, with a new table, a join table , called shows_genres that contains foreign keys that link shows to genres. This is a many-to-many relationship, where one show can have many genres, and one genre can belong to many shows. If we needed to change a genre\u2019s name, we would only have to change one row now, instead of many.","title":"2.3.6. Nested query"},{"location":"notes/Harvard_CS50/0x07_SQL/#237-subtypes","text":"It turns out that there are subtypes for a column, too, that we can be even more specific with: INTEGER smallint , with fewer bits integer bigint , with more bits NUMERIC boolean data datatime numeric(scale, precision) , with a fixed number of digits time timestamp REAL real double precision , with twice as many bits TEXT char(n) , a fixed number of characters varchar(n) , a variable number text , a string with no limit","title":"2.3.7. Subtypes"},{"location":"notes/Harvard_CS50/0x07_SQL/#3-indexes-and-join","text":"","title":"3. Indexes and JOIN"},{"location":"notes/Harvard_CS50/0x07_SQL/#31-what-is-imdb","text":"IMDb, abbreviation for the Internet Movie Database, has datasets available for download as TSV (table-separated values) file.","title":"3.1. What is IMDb"},{"location":"notes/Harvard_CS50/0x07_SQL/#32-schema-of-imdb","text":"After we import one such dataset, we'll see tables with the following schemas: The genres table has some duplication, since the genre column is repeated, but the stars and writers table join rows in the people and shows table based on their relationship.","title":"3.2. Schema of IMDb"},{"location":"notes/Harvard_CS50/0x07_SQL/#33-indexes","text":"With SELECT COUNT(*) FROM shows; we can see that there are more than 150,000 shows in our table, so with a large amount of data we can use indexes , which tells our database program to create additional data structures so we can search and sort with logarithmic time : 1 sqlite> CREATE INDEX title_index on shows(title); It turns out that these data structures are generally B-trees , like binary trees we've seen in C, with nodes organized such that we search faster than linearly. Creating an index takes some time, but afterwards we can run queries much more quickly.","title":"3.3. indexes"},{"location":"notes/Harvard_CS50/0x07_SQL/#34-join","text":"With our data spread among different tables, we can use JOIN commands to combine them in our queries: 1 2 3 4 5 6 7 sqlite3> SELECT title FROM people ...> JOIN stars ON people.id = stars.person_id ...> JOIN shows ON stars.show_id = shows.id ...> WHERE name = \"Steve Carell\"; ... The Morning Show LA Times: the Envelope With the JOIN syntax, we can virtually combine tables based on their foreign keys, and use their columns as though they were one table.","title":"3.4. Join"},{"location":"notes/Harvard_CS50/0x07_SQL/#4-problems","text":"","title":"4. Problems"},{"location":"notes/Harvard_CS50/0x07_SQL/#41-sql-injection-attack","text":"One problem in SQL is called a SQL injection attack , where someone can inject , or place, their own commands into inputs that we then run on our database. Our query for logging a user in might be rows = db.execute(\"SELECT * FROM users WHERE username = ? AND password = ?\", username, password) . By using the ? placeholders, our SQL library will escape the input, or prevent dangerous characters from being interpreted as part of the command. In contrast, we might have a SQL query that\u2019s a formatted string, such as: 1 f \"SELECT * FROM users WHERE username = ' { username } ' AND password = ' { password } '\" If a user types in malan@harvard.edu'-- , then the query will end up being: 1 f \"SELECT * FROM users WHERE username = 'malan@harvard.edu'--' AND password = ' { password } '\" This query will actually select the row where username = 'malan@harvard.edu' , without checking the password, since the -- turns the rest of the line into a comment in SQL.","title":"4.1. SQL injection attack"},{"location":"notes/Harvard_CS50/0x07_SQL/#42-race-conditions","text":"Another problem with databases is race conditions , where code in a multi-threaded environment can be commingled, or mixed together, in each thread. One example is a popular post getting lots of likes. A server might try to increment the number of likes, asking the database for the current number of likes, adding one, and updating the value in the database: 1 2 3 row = db . execute ( \"SELECT likes FROM posts WHERE id = ?\" , id ) likes = row [ 0 ][ \"likes\" ] db . execute ( \"UPDATE posts SET likes = ? WHERE id = ?\" , likes + 1 , id ) But for applications with multiple servers, each of them might trying to add likes at the same time. Two servers, responding to two different users, might get the same starting number of likes since the first line of code runs at the same time on each server. Then, both will set the same new number of likes, even though there should have been two separate increments. To solve this problem, SQL supports transactions , where we can look rows in a database, such that a particular set of actions are guaranteed to happen together, with syntax like: BEGIN TRANSACTION COMMIT ROLLBACK E.g., we can fix our problem above with: 1 2 3 4 5 db . execute ( \"BEGIN TRANSACTION\" ) rows = db . execute ( \"SELECT likes FROM posts WHERE id = ?;\" , id ) likes = rows [ 0 ][ \"likes\" ] db . execute ( \"UPDATE posts SET likes = ? WHERE id = ?;\" , likes + 1 , id ) db . execute ( \"COMMIT\" ) The database will ensure that all the query in between are executed together. Another example might be of two roommates and a shared fridge in their dorm. The first roommate comes home, and sees that there is no milk in the fridge. So the first roommate leaves to the store to buy milk, and while they are at the store, the second roommate comes home, sees that there is no milk, and leaves for another store to get milk as well. Later, there will be two jugs of milk in the fridge. We can solve this problem by locking the fridge so that our roommate can\u2019t check whether there is milk until we\u2019ve gotten back.","title":"4.2. Race conditions"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/","text":"1. The internet 1.1. What is the internet The internet is the network of networks of computers communicating with one another, which provides the infrastructure to send 0 s and 1 s. One the top of that foundation, we can build applications that send and receive data. 1.2. Routers Routers are specialized computers, with CPU and memory, whose purpose is to relay data across cables or wireless technologies, between other devices on the internet, so that the data can be send far away ,like from China to USA. 1.3. Protocols Protocols are a set of standard conventions, like a physical handshake, that the world has agree upon for computers to communicate with. E.g., there are certain patterns of 0 s and 1 s, or messages, a computer has to tell a router where it wants to send data. 1.4. TCP/IP TCP/IP are two protocols for sending data between two computers. In the real world, we might write an address on an envelope in order to send a letter to someone, along with our own address for a letter in return. The digital version of an envelope, or a message with from and to address, is called a packet . IP stands for i nternet p rotocol, a protocol supported by modern computers' software, which includes a standard way for computers to address with each others. IP addresses are unique addresses for computers connected to the internet, such a packet sent from one computer for another will be passed along routers until reaches its destination. Routers have, in their memory, a table mapping IP addresses to cable each connected to other routers, so they know where to forward packets to. It turns out that there are protocols for routers for routers to communicate and figure out these paths as well. DNS , d omain n ame s ystem, is another technology that translates domain names like www.google.com to IP addresses. DNS is generally provided as a service by the internet service provider, i.e. ISP . Finally, TCP , t ransmission c ontrol p rotocol, is one final protocol that allows a single server, at the same IP address, to provide multiple services through the use of a port number , a small integer added to the IP address. E.g., HTTP, HTTPS, email, and even Zoom has their own port numbers for those programs to use to communicate over the network. TCP also provides a mechanism for resending packets if a packet is somehow lost and not received. It turns out that, on the internet, there are multiple paths for a packet to be sent since there are lots of routers that are connected. So a web browser, making a request for a cat, might see its packet sent through one path of routers, and the responding server might see its response packets sent through another. A large amount of data, such as a picture, will be broken into smaller chunks so that the packets are all of a similar size. This way, routers along the internet can send everyone's packets more fairly and easily. Net neutrality refers to the idea that these pubic routers treat packets equally, as opposed to allowing packets from certain companies or of certain types to be prioritized. When there are multiple packets for a single response, TCP will also specify that each of them be labeled, as with \u201c1 of 2\u201d or \u201c2 of 2\u201d, so they can be combined or re-sent as needed. With all of these technologies and protocols, we\u2019re able to send data from one computer to another, and can abstract the internet away, to build applications on top. 2. Web development 2.1. What is Web development The web is one application running one the top of the internet, allowing us to get web pages. Other applications like Zoom provide video conferencing, and email is another application as well. 2.2. HTTP HTTP , or Hypertext Transfer Protocol, governs how web browsers and web servers communicate with TCP/IP packets. Two commands supported by HTTP include GET and POST . GET allows a browser to ask for a page for a file POST allows a browser to send data to the server. POST doesn't include the form's data in the URL, but elsewhere in the request. A URL , Uniform Resource Locator or web address, might look like https://www.example.com/ https is the protocol being used, and in this case HTTPS is the secure version of HTTP, ensuring that the contents of packets between the browser and server are encrypted. example.com is the domain name, where .com is the top-level domain, conventionally indicating the \"type\" of website, like commercial website for .com , or organization for .org . Now there are hundreds of top-level domains, and they vary in restrictions on who can use them, but many of them allow anyone to register for a domain. www is the hostname that, by convention, indicates to us that this is a \u201cworld wide web\u201d service. It\u2019s not required, so today many websites aren\u2019t configured to include it. Finally, the / at the end is a request for the default file, like index.html , that the web server will respond with. 2.3. Requests and Responses An HTTP request will start with: 1 2 3 GET / HTTP / 1.1 Host : www.example.com ... The GET indicates that the request is for some file, and / indicates the default file. A request could be more specific, and start with GET /index.html . There are different versions of the HTTP protocol, so HTTP/1.1 indicates that the browser is using version 1.1. Host: www.example.com indicates that the request is for www.example.com , since the same web server might be hosting multiple websites and domains. An HTTP can include inputs to servers, like the strings q=cats after ? : 1 2 3 GET /search?q=cats HTTP / 1.1 Host : www.google.com ... A response will start with: 1 2 3 HTTP / 1.1 200 OK Content-Type : text/html ... The web server will respond with the version of HTTP, followed by a status code, which is 200 OK here, indicating that the request was valid. Then, the web server indicates the type of content in its response, which might be text, image, or other format. Finally, the rest of the packet or packets will include the content. 2.4. Status codes We can see a redirect in a browser by typing in a URL, like http://www.harvard.edu , and looking at the address bar after the page has loaded, which will show https://www.harvard.edu . Browsers include developer tools, which allow us to see what\u2019s happening. In Chrome\u2019s menu, for example, we can go to View > Developer > Developer Tools, which will open a panel on the screen. In the Network tab, we can see that there were many requests, for text, images, and other pieces of data that were downloaded separately for the single web pages. The first request actually returned a status code of 301 Moved Permanently , redirecting our browser from http://... to https://... : The request and response also includes a number of headers, or additional data: Note that the response includes a Location: header for the browser to redirect us to. Other HTTP status codes include: 200 OK 301 Moved Permanently 304 Not Modified This allows the browser to use its cache, or local copy, of some resource like an image, instead of having the server send it back again. 307 Temporary Redirect 401 Unauthorized 403 Forbidden 404 Not Found 418 I'm a Teapot 500 Internal Server Error Buggy code on a server might result in this status code. 503 Service Unavailable \u2026 3. Contents for web pages 3.1. HTML Since we can use the internet and HTTP to send and receive messages, now we can see what's in the content for web pages. It turns out that HTML , Hypertext Markup Language, is not a programming language, but rather used to format web pages and tell the browser how to display pages, using tag s and attribute s. A simple page in HTML might look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!DOCTYPE html> <!-- A declaration that page follows the HTML standard --> <!-- this's a \"tag\", start with <tag> and end with </tag> --> < html lang = \"en\" > <!-- if the tag's name is html, it indicate the start and the end of the HTML page --> <!-- \"lang\" here is a \"attribute\", which specifie the language of this page --> < head > < title > <!-- the title of this page we'll see in tab --> hello, title </ title > </ head > < body > <!-- the main view of this page --> hello, body </ body > </ html > The page above will be loaded into the browser as a data structure, like this tree: Each of HTML tags have two child tags, head and body . Notice that rectangular nodes are tags, while oval ones are text. There are other tag s for other usages: <p> , for a paragraph <h[1-6]> , for headings <ul> , for an unordered list <ol> , for an ordered list with numbers <table> , for table <tr> as rows <td> for individual cells, which stand for table data <img alt=? src=?> , img tag for images alt attribute for alternative text for accessibility src attribute for the source file of this image <a href=?>text<\\a> , a tag for an anchor, we can use it for hyperlink. href attribute is for a hypertext reference Within the tag is the text that should appear as the link We could prank users with this, so the users will be tricked into visiting a fake version of some website. Phishing is an act of tricking users, a form of social engineering that includes misleading links. By looking for documentation or other online resources, we can learn the tags that exist in HTML, and how to use them. There is an example we can create a more complex form that takes user input and sends it to Google's search engine. 1 2 3 4 5 6 7 8 9 10 11 12 13 <!DOCTYPE html> < html lang = \"en\" > < head > < title > search </ title > </ head > < body > < form action = \"https://www.google.com/search\" method = \"get\" > < input name = \"q\" type = \"search\" > < input type = \"submit\" value = \"Search\" > </ form > </ body > </ html > First, we have a <form> tag that has an action of Google\u2019s search URL, with a method of GET. Inside the form, we have one <input> , with the name q , and another <input> with the type of submit . When the second input, a button, is clicked, the form will append the text in the first input to the action URL, ending it with search?q=... . 3.2. CSS 3.2.1. What is CSS CSS , Cascading Style Sheets, which we can improve the aesthetics of our pages with, it's another language that tells our browser how to display tags of HTML on the page. CSS uses properties , or key-value pairs, like color: red; to tags with selectors. 3.2.2. Including CSS in HTML In order to include CSS in HTML, we have some options: We can add a <style> tag within the <header> tag directly, and put CSS codes inside. Or we can link to an external CSS file with a <link> tag within the <head> tag. We can also include CSS directly in each tag we want. 3.2.3. Include CSS directly in each tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!DOCTYPE html> < html lang = \"en\" > < head > < title > css </ title > </ head > < body > <!-- the third way to include CSS --> < header style = \"font-size: large; text-align: center;\" > John Harvard </ header > < main style = \"font-size: medium; text-align: center;\" > Welcome to my home page! </ main > < footer style = \"font-size: small; text-align: center;\" > Copyright &#169; John Harvard </ footer > </ body > </ html > And notice that <header> , <main> and <footer> tags are like <p> tags, indicating the sections that our text on our page are in. For each of those tags, we can add a style attribute, with the value being a list of CSS key-value properties, separated by semicolons . Here we're setting the font-size for each tag and aligning the text in the center. Note that &#169; , which is an HTML entity , as a code to include some symbol in our web page we cannot type it through our keyboard. We can align all the text at once through apply the style attribute to <body> tag. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!DOCTYPE html> < html lang = \"en\" > < head > < title > css </ title > </ head > < body style = \"text-align: center;\" > < header style = \"font-size: large;\" > John Harvard </ header > < main style = \"font-size: medium;\" > Welcome to my home page! </ main > < footer style = \"font-size: small;\" > Copyright &#169; John Harvard </ footer > </ body > </ html > Here, the style applied to the <body> tag cascades, or applies, to its children, so call the sections inside will have centered text as well. 3.2.4. Separate our CSS from HTML and CSS type selectors To factor out, or separate our CSS from HTML, we can include style in the <head> tag. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 <!DOCTYPE html> < html lang = \"en\" > < head > < style > header { font-size : large ; text-align : center ; } main { font-size : medium ; text-align : center ; } footer { font-size : small ; text-align : center ; } </ style > < title > css </ title > </ head > < body > < header > John Harvard </ header > < main > Welcome to my home page! </ main > < footer > Copyright &#169; John Harvard </ footer > </ body > </ html > For each type of tag, we've used a CSS type selector to style it. We can use a more specific class selector : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 <!DOCTYPE html> < html lang = \"en\" > < head > < style > . centered { text-align : center ; } . large { font-size : large ; } . medium { font-size : medium ; } . small { font-size : small ; } </ style > < title > css </ title > </ head > < body > < header class = \"centered large\" > John Harvard </ header > < main class = \"centered medium\" > Welcome to my home page! </ main > < footer class = \"centered small\" > Copyright &#169; John Harvard </ footer > </ body > </ html > We've define our own CSS class with a . followed by a keyword we choose, each of those class have some property for font size or aligning. Therefore we could reuse these classes by adding them to the attribute of our HTML tags, and it can have one or more classes for one tag. 3.2.5. Link an external CSS file Finally, we can take all of the CSS for the properties and move them to another file with the <link> tag, rel for the relation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!DOCTYPE html> < html lang = \"en\" > < head > < link href = \"styles.css\" rel = \"stylesheet\" > < title > css </ title > </ head > < body > < header class = \"centered large\" > John Harvard </ header > < main class = \"centered medium\" > Welcome to my home page! </ main > < footer class = \"centered small\" > Copyright &#169; John Harvard </ footer > </ body > </ html > 3.2.6. More properties and selectors With CSS, we'll also rely on references and other resources to look up how to use properties as we need them. We can use pseudoselectors , which selects certain states: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 <!DOCTYPE html> < html lang = \"en\" > < head > < style > # harvard { color : #ff0000 ; } # yale { color : #0000ff ; } a { text-decoration : none ; } a : hover { text-decoration : underline ; } </ style > < title > link </ title > </ head > < body > Visit < a href = \"https://www.harvard.edu/\" id = \"harvard\" > Harvard </ a > or < a href = \"https://www.yale.edu/\" id = \"yale\" > Yale </ a > . </ body > </ html > Here, we're using a: hover to set properties on <a> tags when the users hovers over them. We also have an id attribute on each <a> tag, to set different colors on each with ID selectors that start with a # in CSS. 3.3. JavaScript 3.3.1. What is JavaScript To write code we can run in users' browsers, or on the client, we'll use a new language, JavaScript . The syntax of JavaScript is similar to that of C for basic constructs, except for variable declaration: 1 2 let name = 'hello' ; let i = 3 ; We use the keyword let to declare any variable, instead of the type of this variable. That is because JavaScript is a loosely typed language same as Python. With JavaScript, we can change HTML in the browser in real-time. We can use <script> tags to include our code directly, or from a .js file just like CSS. 3.3.2. JavaScript functions and DOM We can create a greet function in JavaScript to interact with user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!DOCTYPE html> < html lang = \"en\" > < head > < script > function greet () { alert ( 'hello, body' ); } </ script > < title > hello </ title > </ head > < body > < form onsubmit = \"greet(); return false;\" > < input id = \"name\" type = \"text\" > < input type = \"submit\" > </ form > </ body > </ html > We won't add a action to our form, since this will stay on the same page. Instead, we'll have an onsubmit attribute that will call a function we've defined in JS, and use return false; to prevent the form from actually being submit anywhere. Since our input tag, or element , has an ID of name , we can use it in our script: 1 2 3 4 5 6 7 < script > function greet () { let name = document . querySelector ( '#name' ). value ; alert ( 'Hello, ' , + name ) } </ script > Where document is a global variable that comes with JavaScript in the browser, and querySelector is another function we can use to select a node in the DOM , Document Object Model, or the tree structure of the HTML page. After we select the element with the ID name , we get the value inside the input, and add it to our alert. Notice that JS uses single quotes for strings by convention, though double quotes can be used as well as long as they match for each string. We can also add more attributes to our form, to change placeholder text, change the button's text, disable autocomplete, or autofocus the input. 1 2 3 4 < form > < input autocomplete = \"off\" autofocus id = \"name\" placeholder = \"Name\" type = \"text\" > < input type = \"submit\" > </ form > 3.3.3. Listening events We can also listen to events in JS, which occur when something happens on the page. For example, we can listen to the submit event on our form, and call the greet function when it's happened. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 < script > function greet () { let name = document . querySelector ( '#name' ). value ; alert ( 'hello, ' + name ); } function listen () { document . querySelector ( 'form' ). addEventListener ( 'submit' , greet ); } document . addEventListener ( 'DOMContentLoaded' , listen ); </ script > Notice in listen function we pass the function greet by name, and not call it yet. The event listener will call it for us when the event happens. We need first to listen to the DOMContentLoaded event, since the browser reads our HTML file from top to bottom, and form wouldn't exist until it's read the entire file and loaded the content. So by listening to this event, and calling our listen function, we know form will exist. We can also use anonymous function in JS: 1 2 3 4 5 6 7 8 9 10 < script > document . addEventListener ( 'DOMContentLoaded' , function () { document . querySelector ( 'form' ). addEventListener ( 'submit' , function () { let name = document . querySelector ( '#name' ). value ; alert ( 'hello, ' + name ); }); }); </ script > We can pass in a lambda function with the function() syntax, so here we\u2019ve passed in both listeners directly to addEventListener . 3.3.4. Other events In addition to submit , there are many other events we can listen to: blur change click drag focus keyup load mousedown mouseover mouseup submit touchmove unload ... For example, we can listen to the keyup event, and change the DOM as soon as we release a key: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 <!DOCTYPE html> < html lang = \"en\" > < head > < script > document . addEventListener ( 'DOMContentLoaded' , function () { let input = document . querySelector ( 'input' ); input . addEventListener ( 'keyup' , function ( event ) { let name = document . querySelector ( '#name' ); if ( input . value ) { name . innerHTML = `hello, ${ input . value } ` ; } else { name . innerHTML = 'hello, whoever you are' ; } }); }); </ script > < title > hello </ title > </ head > < body > < form > < input autocomplete = \"off\" autofocus placeholder = \"Name\" type = \"text\" > </ form > < p id = \"name\" ></ p > </ body > </ html > Notice that we can substitute strings in JS as in Python, with the ${input.value} inside a string surrounded by back-ticks, ` . 3.3.5. Changing Style in JS We can programmatically change style, too. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 <!DOCTYPE html> < html lang = \"en\" > < head > < title > background </ title > </ head > < body > < button id = \"red\" > R </ button > < button id = \"green\" > G </ button > < button id = \"blue\" > B </ button > < script > let body = document . querySelector ( 'body' ); document . querySelector ( '#red' ). onclick = function () { body . style . backgroundColor = 'red' ; }; document . querySelector ( '#green' ). onclick = function () { body . style . backgroundColor = 'green' ; }; document . querySelector ( '#blue' ). onclick = function () { body . style . backgroundColor = 'blue' ; }; </ script > </ body > </ html > After selecting an element, we can use the style property to set values for CSS properties as well. Here, we have three buttons, each of which has an onclick listener that changes the background color of the <body> element. Also notice that our <script> tag is at the end of our HTML file, so we don't need to listen to the DOMContentLoaded event, since the rest of the DOM will already have been read by the browser. 4. My first website 4.1. Planning We'll think about three questions: What's our website about? Just a personal website, like a blog. What information do we presenting on the subject? Any informations about me, so that others could know me through my website. What does our website look like? More tech style, cool 4.2. File structure Our folders and files should completely in lowercase with no space . Many computers, particularly web servers, are case-sensitive . Browsers, web servers, and programming languages do not handle spaces consistently. Long story short, we should use a hyphen - for our file names, rather than underscore _ , cause the Google search engine treats a hyphen as a word separator but does not regard an underscore that way. Our file structure will contain an index HTML file and folders to contain images, style files, and script files. index.html : This file will generally contain our homepage content. image folder : This folder will contain all the images that we use on our website. style folder : This folder will contain the CSS code used to style our content. script folder : This folder will contain all the JavaScript code used to add interactive functionality to your site.","title":"Lec 08: HTML, CSS, JS"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#1-the-internet","text":"","title":"1. The internet"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#11-what-is-the-internet","text":"The internet is the network of networks of computers communicating with one another, which provides the infrastructure to send 0 s and 1 s. One the top of that foundation, we can build applications that send and receive data.","title":"1.1. What is the internet"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#12-routers","text":"Routers are specialized computers, with CPU and memory, whose purpose is to relay data across cables or wireless technologies, between other devices on the internet, so that the data can be send far away ,like from China to USA.","title":"1.2. Routers"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#13-protocols","text":"Protocols are a set of standard conventions, like a physical handshake, that the world has agree upon for computers to communicate with. E.g., there are certain patterns of 0 s and 1 s, or messages, a computer has to tell a router where it wants to send data.","title":"1.3. Protocols"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#14-tcpip","text":"TCP/IP are two protocols for sending data between two computers. In the real world, we might write an address on an envelope in order to send a letter to someone, along with our own address for a letter in return. The digital version of an envelope, or a message with from and to address, is called a packet . IP stands for i nternet p rotocol, a protocol supported by modern computers' software, which includes a standard way for computers to address with each others. IP addresses are unique addresses for computers connected to the internet, such a packet sent from one computer for another will be passed along routers until reaches its destination. Routers have, in their memory, a table mapping IP addresses to cable each connected to other routers, so they know where to forward packets to. It turns out that there are protocols for routers for routers to communicate and figure out these paths as well. DNS , d omain n ame s ystem, is another technology that translates domain names like www.google.com to IP addresses. DNS is generally provided as a service by the internet service provider, i.e. ISP . Finally, TCP , t ransmission c ontrol p rotocol, is one final protocol that allows a single server, at the same IP address, to provide multiple services through the use of a port number , a small integer added to the IP address. E.g., HTTP, HTTPS, email, and even Zoom has their own port numbers for those programs to use to communicate over the network. TCP also provides a mechanism for resending packets if a packet is somehow lost and not received. It turns out that, on the internet, there are multiple paths for a packet to be sent since there are lots of routers that are connected. So a web browser, making a request for a cat, might see its packet sent through one path of routers, and the responding server might see its response packets sent through another. A large amount of data, such as a picture, will be broken into smaller chunks so that the packets are all of a similar size. This way, routers along the internet can send everyone's packets more fairly and easily. Net neutrality refers to the idea that these pubic routers treat packets equally, as opposed to allowing packets from certain companies or of certain types to be prioritized. When there are multiple packets for a single response, TCP will also specify that each of them be labeled, as with \u201c1 of 2\u201d or \u201c2 of 2\u201d, so they can be combined or re-sent as needed. With all of these technologies and protocols, we\u2019re able to send data from one computer to another, and can abstract the internet away, to build applications on top.","title":"1.4. TCP/IP"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#2-web-development","text":"","title":"2. Web development"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#21-what-is-web-development","text":"The web is one application running one the top of the internet, allowing us to get web pages. Other applications like Zoom provide video conferencing, and email is another application as well.","title":"2.1. What is Web development"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#22-http","text":"HTTP , or Hypertext Transfer Protocol, governs how web browsers and web servers communicate with TCP/IP packets. Two commands supported by HTTP include GET and POST . GET allows a browser to ask for a page for a file POST allows a browser to send data to the server. POST doesn't include the form's data in the URL, but elsewhere in the request. A URL , Uniform Resource Locator or web address, might look like https://www.example.com/ https is the protocol being used, and in this case HTTPS is the secure version of HTTP, ensuring that the contents of packets between the browser and server are encrypted. example.com is the domain name, where .com is the top-level domain, conventionally indicating the \"type\" of website, like commercial website for .com , or organization for .org . Now there are hundreds of top-level domains, and they vary in restrictions on who can use them, but many of them allow anyone to register for a domain. www is the hostname that, by convention, indicates to us that this is a \u201cworld wide web\u201d service. It\u2019s not required, so today many websites aren\u2019t configured to include it. Finally, the / at the end is a request for the default file, like index.html , that the web server will respond with.","title":"2.2. HTTP"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#23-requests-and-responses","text":"An HTTP request will start with: 1 2 3 GET / HTTP / 1.1 Host : www.example.com ... The GET indicates that the request is for some file, and / indicates the default file. A request could be more specific, and start with GET /index.html . There are different versions of the HTTP protocol, so HTTP/1.1 indicates that the browser is using version 1.1. Host: www.example.com indicates that the request is for www.example.com , since the same web server might be hosting multiple websites and domains. An HTTP can include inputs to servers, like the strings q=cats after ? : 1 2 3 GET /search?q=cats HTTP / 1.1 Host : www.google.com ... A response will start with: 1 2 3 HTTP / 1.1 200 OK Content-Type : text/html ... The web server will respond with the version of HTTP, followed by a status code, which is 200 OK here, indicating that the request was valid. Then, the web server indicates the type of content in its response, which might be text, image, or other format. Finally, the rest of the packet or packets will include the content.","title":"2.3. Requests and Responses"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#24-status-codes","text":"We can see a redirect in a browser by typing in a URL, like http://www.harvard.edu , and looking at the address bar after the page has loaded, which will show https://www.harvard.edu . Browsers include developer tools, which allow us to see what\u2019s happening. In Chrome\u2019s menu, for example, we can go to View > Developer > Developer Tools, which will open a panel on the screen. In the Network tab, we can see that there were many requests, for text, images, and other pieces of data that were downloaded separately for the single web pages. The first request actually returned a status code of 301 Moved Permanently , redirecting our browser from http://... to https://... : The request and response also includes a number of headers, or additional data: Note that the response includes a Location: header for the browser to redirect us to. Other HTTP status codes include: 200 OK 301 Moved Permanently 304 Not Modified This allows the browser to use its cache, or local copy, of some resource like an image, instead of having the server send it back again. 307 Temporary Redirect 401 Unauthorized 403 Forbidden 404 Not Found 418 I'm a Teapot 500 Internal Server Error Buggy code on a server might result in this status code. 503 Service Unavailable \u2026","title":"2.4. Status codes"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#3-contents-for-web-pages","text":"","title":"3. Contents for web pages"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#31-html","text":"Since we can use the internet and HTTP to send and receive messages, now we can see what's in the content for web pages. It turns out that HTML , Hypertext Markup Language, is not a programming language, but rather used to format web pages and tell the browser how to display pages, using tag s and attribute s. A simple page in HTML might look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!DOCTYPE html> <!-- A declaration that page follows the HTML standard --> <!-- this's a \"tag\", start with <tag> and end with </tag> --> < html lang = \"en\" > <!-- if the tag's name is html, it indicate the start and the end of the HTML page --> <!-- \"lang\" here is a \"attribute\", which specifie the language of this page --> < head > < title > <!-- the title of this page we'll see in tab --> hello, title </ title > </ head > < body > <!-- the main view of this page --> hello, body </ body > </ html > The page above will be loaded into the browser as a data structure, like this tree: Each of HTML tags have two child tags, head and body . Notice that rectangular nodes are tags, while oval ones are text. There are other tag s for other usages: <p> , for a paragraph <h[1-6]> , for headings <ul> , for an unordered list <ol> , for an ordered list with numbers <table> , for table <tr> as rows <td> for individual cells, which stand for table data <img alt=? src=?> , img tag for images alt attribute for alternative text for accessibility src attribute for the source file of this image <a href=?>text<\\a> , a tag for an anchor, we can use it for hyperlink. href attribute is for a hypertext reference Within the tag is the text that should appear as the link We could prank users with this, so the users will be tricked into visiting a fake version of some website. Phishing is an act of tricking users, a form of social engineering that includes misleading links. By looking for documentation or other online resources, we can learn the tags that exist in HTML, and how to use them. There is an example we can create a more complex form that takes user input and sends it to Google's search engine. 1 2 3 4 5 6 7 8 9 10 11 12 13 <!DOCTYPE html> < html lang = \"en\" > < head > < title > search </ title > </ head > < body > < form action = \"https://www.google.com/search\" method = \"get\" > < input name = \"q\" type = \"search\" > < input type = \"submit\" value = \"Search\" > </ form > </ body > </ html > First, we have a <form> tag that has an action of Google\u2019s search URL, with a method of GET. Inside the form, we have one <input> , with the name q , and another <input> with the type of submit . When the second input, a button, is clicked, the form will append the text in the first input to the action URL, ending it with search?q=... .","title":"3.1. HTML"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#32-css","text":"","title":"3.2. CSS"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#321-what-is-css","text":"CSS , Cascading Style Sheets, which we can improve the aesthetics of our pages with, it's another language that tells our browser how to display tags of HTML on the page. CSS uses properties , or key-value pairs, like color: red; to tags with selectors.","title":"3.2.1. What is CSS"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#322-including-css-in-html","text":"In order to include CSS in HTML, we have some options: We can add a <style> tag within the <header> tag directly, and put CSS codes inside. Or we can link to an external CSS file with a <link> tag within the <head> tag. We can also include CSS directly in each tag we want.","title":"3.2.2. Including CSS in HTML"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#323-include-css-directly-in-each-tag","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!DOCTYPE html> < html lang = \"en\" > < head > < title > css </ title > </ head > < body > <!-- the third way to include CSS --> < header style = \"font-size: large; text-align: center;\" > John Harvard </ header > < main style = \"font-size: medium; text-align: center;\" > Welcome to my home page! </ main > < footer style = \"font-size: small; text-align: center;\" > Copyright &#169; John Harvard </ footer > </ body > </ html > And notice that <header> , <main> and <footer> tags are like <p> tags, indicating the sections that our text on our page are in. For each of those tags, we can add a style attribute, with the value being a list of CSS key-value properties, separated by semicolons . Here we're setting the font-size for each tag and aligning the text in the center. Note that &#169; , which is an HTML entity , as a code to include some symbol in our web page we cannot type it through our keyboard. We can align all the text at once through apply the style attribute to <body> tag. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 <!DOCTYPE html> < html lang = \"en\" > < head > < title > css </ title > </ head > < body style = \"text-align: center;\" > < header style = \"font-size: large;\" > John Harvard </ header > < main style = \"font-size: medium;\" > Welcome to my home page! </ main > < footer style = \"font-size: small;\" > Copyright &#169; John Harvard </ footer > </ body > </ html > Here, the style applied to the <body> tag cascades, or applies, to its children, so call the sections inside will have centered text as well.","title":"3.2.3. Include CSS directly in each tag"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#324-separate-our-css-from-html-and-css-type-selectors","text":"To factor out, or separate our CSS from HTML, we can include style in the <head> tag. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 <!DOCTYPE html> < html lang = \"en\" > < head > < style > header { font-size : large ; text-align : center ; } main { font-size : medium ; text-align : center ; } footer { font-size : small ; text-align : center ; } </ style > < title > css </ title > </ head > < body > < header > John Harvard </ header > < main > Welcome to my home page! </ main > < footer > Copyright &#169; John Harvard </ footer > </ body > </ html > For each type of tag, we've used a CSS type selector to style it. We can use a more specific class selector : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 <!DOCTYPE html> < html lang = \"en\" > < head > < style > . centered { text-align : center ; } . large { font-size : large ; } . medium { font-size : medium ; } . small { font-size : small ; } </ style > < title > css </ title > </ head > < body > < header class = \"centered large\" > John Harvard </ header > < main class = \"centered medium\" > Welcome to my home page! </ main > < footer class = \"centered small\" > Copyright &#169; John Harvard </ footer > </ body > </ html > We've define our own CSS class with a . followed by a keyword we choose, each of those class have some property for font size or aligning. Therefore we could reuse these classes by adding them to the attribute of our HTML tags, and it can have one or more classes for one tag.","title":"3.2.4. Separate our CSS from HTML and CSS type selectors"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#325-link-an-external-css-file","text":"Finally, we can take all of the CSS for the properties and move them to another file with the <link> tag, rel for the relation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 <!DOCTYPE html> < html lang = \"en\" > < head > < link href = \"styles.css\" rel = \"stylesheet\" > < title > css </ title > </ head > < body > < header class = \"centered large\" > John Harvard </ header > < main class = \"centered medium\" > Welcome to my home page! </ main > < footer class = \"centered small\" > Copyright &#169; John Harvard </ footer > </ body > </ html >","title":"3.2.5. Link an external CSS file"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#326-more-properties-and-selectors","text":"With CSS, we'll also rely on references and other resources to look up how to use properties as we need them. We can use pseudoselectors , which selects certain states: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 <!DOCTYPE html> < html lang = \"en\" > < head > < style > # harvard { color : #ff0000 ; } # yale { color : #0000ff ; } a { text-decoration : none ; } a : hover { text-decoration : underline ; } </ style > < title > link </ title > </ head > < body > Visit < a href = \"https://www.harvard.edu/\" id = \"harvard\" > Harvard </ a > or < a href = \"https://www.yale.edu/\" id = \"yale\" > Yale </ a > . </ body > </ html > Here, we're using a: hover to set properties on <a> tags when the users hovers over them. We also have an id attribute on each <a> tag, to set different colors on each with ID selectors that start with a # in CSS.","title":"3.2.6. More properties and selectors"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#33-javascript","text":"","title":"3.3. JavaScript"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#331-what-is-javascript","text":"To write code we can run in users' browsers, or on the client, we'll use a new language, JavaScript . The syntax of JavaScript is similar to that of C for basic constructs, except for variable declaration: 1 2 let name = 'hello' ; let i = 3 ; We use the keyword let to declare any variable, instead of the type of this variable. That is because JavaScript is a loosely typed language same as Python. With JavaScript, we can change HTML in the browser in real-time. We can use <script> tags to include our code directly, or from a .js file just like CSS.","title":"3.3.1. What is JavaScript"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#332-javascript-functions-and-dom","text":"We can create a greet function in JavaScript to interact with user. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <!DOCTYPE html> < html lang = \"en\" > < head > < script > function greet () { alert ( 'hello, body' ); } </ script > < title > hello </ title > </ head > < body > < form onsubmit = \"greet(); return false;\" > < input id = \"name\" type = \"text\" > < input type = \"submit\" > </ form > </ body > </ html > We won't add a action to our form, since this will stay on the same page. Instead, we'll have an onsubmit attribute that will call a function we've defined in JS, and use return false; to prevent the form from actually being submit anywhere. Since our input tag, or element , has an ID of name , we can use it in our script: 1 2 3 4 5 6 7 < script > function greet () { let name = document . querySelector ( '#name' ). value ; alert ( 'Hello, ' , + name ) } </ script > Where document is a global variable that comes with JavaScript in the browser, and querySelector is another function we can use to select a node in the DOM , Document Object Model, or the tree structure of the HTML page. After we select the element with the ID name , we get the value inside the input, and add it to our alert. Notice that JS uses single quotes for strings by convention, though double quotes can be used as well as long as they match for each string. We can also add more attributes to our form, to change placeholder text, change the button's text, disable autocomplete, or autofocus the input. 1 2 3 4 < form > < input autocomplete = \"off\" autofocus id = \"name\" placeholder = \"Name\" type = \"text\" > < input type = \"submit\" > </ form >","title":"3.3.2. JavaScript functions and DOM"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#333-listening-events","text":"We can also listen to events in JS, which occur when something happens on the page. For example, we can listen to the submit event on our form, and call the greet function when it's happened. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 < script > function greet () { let name = document . querySelector ( '#name' ). value ; alert ( 'hello, ' + name ); } function listen () { document . querySelector ( 'form' ). addEventListener ( 'submit' , greet ); } document . addEventListener ( 'DOMContentLoaded' , listen ); </ script > Notice in listen function we pass the function greet by name, and not call it yet. The event listener will call it for us when the event happens. We need first to listen to the DOMContentLoaded event, since the browser reads our HTML file from top to bottom, and form wouldn't exist until it's read the entire file and loaded the content. So by listening to this event, and calling our listen function, we know form will exist. We can also use anonymous function in JS: 1 2 3 4 5 6 7 8 9 10 < script > document . addEventListener ( 'DOMContentLoaded' , function () { document . querySelector ( 'form' ). addEventListener ( 'submit' , function () { let name = document . querySelector ( '#name' ). value ; alert ( 'hello, ' + name ); }); }); </ script > We can pass in a lambda function with the function() syntax, so here we\u2019ve passed in both listeners directly to addEventListener .","title":"3.3.3. Listening events"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#334-other-events","text":"In addition to submit , there are many other events we can listen to: blur change click drag focus keyup load mousedown mouseover mouseup submit touchmove unload ... For example, we can listen to the keyup event, and change the DOM as soon as we release a key: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 <!DOCTYPE html> < html lang = \"en\" > < head > < script > document . addEventListener ( 'DOMContentLoaded' , function () { let input = document . querySelector ( 'input' ); input . addEventListener ( 'keyup' , function ( event ) { let name = document . querySelector ( '#name' ); if ( input . value ) { name . innerHTML = `hello, ${ input . value } ` ; } else { name . innerHTML = 'hello, whoever you are' ; } }); }); </ script > < title > hello </ title > </ head > < body > < form > < input autocomplete = \"off\" autofocus placeholder = \"Name\" type = \"text\" > </ form > < p id = \"name\" ></ p > </ body > </ html > Notice that we can substitute strings in JS as in Python, with the ${input.value} inside a string surrounded by back-ticks, ` .","title":"3.3.4. Other events"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#335-changing-style-in-js","text":"We can programmatically change style, too. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 <!DOCTYPE html> < html lang = \"en\" > < head > < title > background </ title > </ head > < body > < button id = \"red\" > R </ button > < button id = \"green\" > G </ button > < button id = \"blue\" > B </ button > < script > let body = document . querySelector ( 'body' ); document . querySelector ( '#red' ). onclick = function () { body . style . backgroundColor = 'red' ; }; document . querySelector ( '#green' ). onclick = function () { body . style . backgroundColor = 'green' ; }; document . querySelector ( '#blue' ). onclick = function () { body . style . backgroundColor = 'blue' ; }; </ script > </ body > </ html > After selecting an element, we can use the style property to set values for CSS properties as well. Here, we have three buttons, each of which has an onclick listener that changes the background color of the <body> element. Also notice that our <script> tag is at the end of our HTML file, so we don't need to listen to the DOMContentLoaded event, since the rest of the DOM will already have been read by the browser.","title":"3.3.5. Changing Style in JS"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#4-my-first-website","text":"","title":"4. My first website"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#41-planning","text":"We'll think about three questions: What's our website about? Just a personal website, like a blog. What information do we presenting on the subject? Any informations about me, so that others could know me through my website. What does our website look like? More tech style, cool","title":"4.1. Planning"},{"location":"notes/Harvard_CS50/0x08_HTML%2C%20CSS%2C%20JavaScript/#42-file-structure","text":"Our folders and files should completely in lowercase with no space . Many computers, particularly web servers, are case-sensitive . Browsers, web servers, and programming languages do not handle spaces consistently. Long story short, we should use a hyphen - for our file names, rather than underscore _ , cause the Google search engine treats a hyphen as a word separator but does not regard an underscore that way. Our file structure will contain an index HTML file and folders to contain images, style files, and script files. index.html : This file will generally contain our homepage content. image folder : This folder will contain all the images that we use on our website. style folder : This folder will contain the CSS code used to style our content. script folder : This folder will contain all the JavaScript code used to add interactive functionality to your site.","title":"4.2. File structure"}]}